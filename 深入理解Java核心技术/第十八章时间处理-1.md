### 第18章 时间处理

#### 18.1 什么是时区

在没有钟表的年代，一开始人们根据太阳在天空的位置来大致确定时间，慢慢地人们根据太阳照射到的物体投下的影子来确定时间。

例如，古代人们使用的日晷，就是人类利用日影测得时刻的一种计时仪器。

在一天中，被太阳照射到的物体投下的影子在不断地改变着：

- 第一是影子的长短在改变。早晨的影子最长，随着时间的推移，影子逐渐变短，一过中午它又重新变长。

- 第二是影子的方向在改变。在北回归线以北的地方，早晨的影子在西方，中午的影子在北方，傍晚的影子在东方。从计时原理上来说，根据影子的长度或方向都可以计时，但根据影子的方向来计时更方便一些，所以通常都以影子的方位计时。



随着时间的推移，晷针上的影子慢慢地由西向东移动。移动的晷针影子好像是现代钟表的指针，晷面则是钟表的表面，以此来显示时刻。

但是，由于地球的自转，不同经度地区的时间有所不同（地方时）。东边的地点比西边的地点先看到日出，东边地点的时刻较早，西边地点的时刻较晚。

世界上各个国家位于地球不同位置，因此不同国家，特别是东西跨度大的国家，日出、日落的时间必定有所偏差，这些偏差就是所谓的时差。



为了照顾各地区的使用方便，又使其他地方的人容易将本地的时间换算成别的地方的时间，在1863年，人们首次提出了时区的概念。

有关国际会议决定将地球表面按经线从东到西划分成一个个区域，并且规定相邻区域的时间相差1小时。

在同一区域内的东端和西端的人看到太阳升起的时间最多相差1小时。当人们跨过一个区域后，就将自己的时钟校正1小时（向西减1小时，向东加1小时），跨过几个区域就加或减几小时。

现今全球共分为24个时区。



**1. 格林尼治时间**

我们说中国在时区上是东八区，一般用GMT+8来表示，日本是东九区，一般用GMT+9来表示。

也就是说，中国时间是在GMT时间的基础上加8个小时，而日本时间是在GMT时间的基础上加9个小时，所以日本时间会比中国时间“快”一个小时。

那么到底什么是GMT呢？

GMT是Greenwich Mean Time的缩写，即格林尼治时间（格林尼治平时），是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。

自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。国际天文学联合会于1928年决定，将由格林尼治平子夜起算的平太阳时作为世界时，也就是通常所说的格林尼治时间。



**2. 理论时区与法定时区**

理论时区以被15整除的子午线为中心，向东西两侧延伸7.5°，即每15°划分一个时区，这是理论时区。

理论时区的时间采用其中央经线（或标准经线）的地方时。所以每差一个时区，区时相差一个小时，相差多少个时区，就相差多少个小时。东边的时区时间比西边的时区时间早。

但是，各个国家和地区具体采用哪个时区其实是自己可以决定的，理论时区只是建议性的。为了避开国界线，有时区的形状并不规则，而且比较大的国家以国家内部行政分界线为时区界线，这是实际时区，即法定时区。

例如，中国幅员辽阔，在理论时区上，差不多跨了5个时区，包括东五区、东六区、东七区、东八区和东九区。如果严格按照地理划分，那么乌鲁木齐的时间可能和黑龙江的时间相差四个小时。

为了方便管理和使用，中国的法定时区以东八时区的标准时即北京时间为准。所以，中国时间俗称北京时间。

这样做的好处不言而喻，缺点也比较明显，就是同样是早上四点，有的地区天已经亮了，有的地区的天还是黑的。



**3. 代码中获取不同时区的时间**

Java中使用TimeZone表示时区偏移量。TimeZone表示原始的偏移量，也就是与GMT相差的微秒数，即TimeZone表示时区偏移量，本质上以毫秒数保存与GMT的差值。

可以通过时区ID获取TimeZone，如"America/New_York"，也可以通过GMT+/-hh:mm来设定。例如，北京时间可以表示为GMT+8:00。

当我们想要输出美国洛杉矶的时间时，可以选择以下这种方式：

```java
TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
Date date = new Date();
System.out.println(date);
```
需要注意的是，以下代码是无法获得美国洛杉矶的时间的：
```java
System.out.println(Calendar.getInstance(TimeZone.getTimeZone("America/Los_Angeles")).getTime());
```
因为当我们使用System.out.println输出一个时间时，会调用Date类的toString方法，而该方法会读取操作系统的默认时区来进行时间的转换。只有修改了默认时区才会显示该时区的时间。

通过阅读Calendar的源码，我们可以发现，getInstance方法虽然有一个参数可以传入时区，但并没有将默认时区设置成传入的时区。

而执行Calendar.getInstance.getTime后得到的时间只是一个时间戳，其中未保留任何和时区有关的信息，所以，在输出时，显示的还是当前系统默认时区的时间。

Java8提供了一套新的时间处理API，这套API比以前的时间处理API要友好得多。Java8中加入了对时区的支持，带时区的时间分别为ZonedDate、ZonedTime和ZonedDateTime。其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，如Asia/Shanghai、America/Los_Angeles等。

在Java8中，直接使用以下代码即可输出美国洛杉矶的时间：

```java
LocalDateTime now = LocalDateTime.now(ZoneId.of("America/Los_Angeles"));
System.out.println(now);
```


#### 18.2 时间戳

1969年8月，贝尔实验室的程序员肯·汤普逊利用妻儿离开一个月的机会，开始着手创造一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了UNIX的一个版本。

随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了UNIX，新版本于1971年发布。

在UNIX被发明出来之后，需要想办法定义一个在某个特定时间之前已经存在的、完整的、可验证的数据来表示时间。

于是，UNIX时间戳被定义出来，即对比当前时间和“纪元时间”，两者相差的秒数作为时间戳。

为了让UNIX时间戳表示时间的这种方式用得尽可能久，最初把UNIX诞生的时间1971-1-1定义为“纪元时间”。

除了开始时间是1971-1-1而不是1970-1-1，最初的时间戳也不是每增加1秒时间戳就变动一次，而是每1/60秒都会改变一次时间戳。

另外，UNIX是在1971年发明出来的，当时的计算机系统是32位的，系统时间的最大值是2147483647（2^31 - 1）。

如果用当时的时间戳计算方式来表示时间，那么UNIX时间戳最多可以使用4294967296/（606024）/60 = 828.5天（一天有606024秒，每1/60秒会占用一个时间戳）。

想象一下，一个计算机系统的时间只能表示828.5天，是不是很难让人接受？但最初的UNIX确实是这样的。

后来，UNIX的开发者也意识到这样不是长久之计，于是开始做出改变。

最开始，他们将每1/60秒改变一次时间戳修改成每1秒改变一次时间戳。这样时间戳可以表示的时间就放大了60倍，这时候有828.5×60/365 = 136年。

一方面136年已经足够久了，纪元时间稍微向前调一下影响也不大。另一方面为了方便记忆和使用，就把纪元时间从1971-01-01调整到1970-01-01了。

后面诞生的各种开发语言都沿袭了1970-1-1这个设定。


所以，通常我们说的时间戳，就是指格林尼治时间（GMT）1970年01月01日00时00分00秒起至现在的总秒数。

1970-01-01对于开发者来说是不陌生的，如果有些系统对时间的处理不够好，则可能把时间显示成1970-01-01。

下面复现这种情况，使用以下Java代码定义时间：

```java
Date date = new Date(0);
System.out.println(date);
```
打印出来的结果如下：
```
Thu Jan 01 08:00:00 CST 1970
```
通过Date的构造函数的Java Doc说明，我们也能得到一些“蛛丝马迹”，如图18-1所示。
```java
/**
 * Allocates a <code>Date</code> object and initializes it to
 * represent the specified number of milliseconds since the
 * standard base time known as "the epoch", namely January 1,
 * * 1970, 00:00:00 GMT.
 * @param date the milliseconds since January 1, 1970, 00:00:00 GMT.
 * @see java.lang.System#currentTimeMillis()
 */
public Date(long date) {
    fastTime = date;
}
```

该构造函数接收用户指定的一个毫秒数值，如new Date(1000)，表示获得一个距离“epoch”有1000毫秒的时间。在Java中，这个时间是1970 00:00:00 GMT。

上面输出的结果是08:00:00而不是00:00:00，这和前面介绍的时区有关，中国处于东八区，时间会比标准时间早8小时。

![image](https://github.com/user-attachments/assets/2209a05e-5a73-4b41-be24-d072cf14818f)


#### 18.3 几种常见时间的含义和关系
**1. CET**

欧洲中部时间（Central European Time，CET）是比世界标准时间（UTC）早一个小时的时区名称之一，它被大部分欧洲国家和部分北非国家采用，冬季时间为UTC+1，夏季欧洲夏令时为UTC+2。



**2. UTC**

协调世界时又称世界标准时间或世界协调时间，简称UTC。协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。



**3. GMT**
格林尼治标准时间（旧译格林尼治平均时间或格林尼治标准时间）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间。

**4. CST**
北京时间（China Standard Time，又名中国标准时间）是中国的标准时间。在时区划分上属东八区，比协调世界时早8小时，记为UTC+8。

**5. 关系**
- CET = UTC/GMT +1小时。
- CST = UTC/GMT +8小时。
- CST = CET +7小时。

#### 18.4 SimpleDateFormat的线程安全性问题

在日常开发中，我们经常会用到时间，我们有很多办法在Java代码中获取时间。但不同的方法获取到的时间的格式不尽相同，这时就需要一种格式化工具，把时间显示成我们需要的格式。

最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但一旦使用不当，也有可能导致很大的问题。

在《阿里巴巴Java开发手册》中，有如下明确规定，如图18-2所示。
```
5.【强制】SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。
```


**18.4.1 SimpleDateFormat的用法**

SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期→文本）、解析（文本→日期）和规范化操作。

在Java中，可以使用SimpleDateFormat的format方法将一个Date类型转化成String类型，并且可以指定输出格式：

```java

// Date转String

Date data = new Date();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String dataStr = sdf.format(data);
System.out.println(dataStr);
```
以上代码转换的结果是2018-11-25 13:00:00，日期和时间格式由“日期和时间模式”字符串指定。如果要转换成其他格式，那么只要指定不同的时间模式即可。

在Java中，可以使用SimpleDateFormat的parse方法将一个String类型转化成Date类型：
```java
// String转Date
System.out.println(sdf.parse(dataStr));
```


**1. 日期和时间模式的表达方法**

在使用SimpleDateFormat时，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母如图18-3所示。

|字母|日期或时间元素|表示|示例|
| ---- | ---- | ---- | ---- |
|G|Era标志符|Text|AD|
|y|年|Year|1996; 96|
|M|年中的月份|Month|July; Jul; 07|
|w|年中的周数|Number|27|
|W|月份中的周数|Number|2|
|D|年中的天数|Number|189|
|d|月份中的天数|Number|10|
|F|月份中的星期|Number|2|
|E|星期中的天数|Text|Tuesday; Tue|
|a|Am/pm标记|Text|PM|
|H|一天中的小时数（0-23）|Number|0|
|k|一天中的小时数（1-24）|Number|24|
|h|am/pm中的小时数（0-11）|Number|0|
|K|am/pm中的小时数（1-12）|Number|12|
|m|小时中的分钟数|Number|30|
|s|分钟中的秒数|Number|55|
|S|毫秒数|Number|978|
|z|时区|General time zone|Pacific Standard Time; PST; GMT-08:00|
|Z|时区|RFC 822 time zone|-0800|

模式字母通常是重复的，其数量确定其精确程度。常用的输出格式的表示方法如图18-4所示。

|日期和时间模式|结果|
| ---- | ---- |
|"yyyy.MM.dd G 'at' HH:mm:ss z"|2001.07.04 AD at 12:08:56 PDT|
|"EEE, MMM d, ''yy"|Wed, Jul 4, '01|
|"h:mm a"|12:08 PM|
|"hh 'o''clock' a, zzzz"|12 o'clock PM, Pacific Daylight Time|
|"K:mm a, z"|0:08 PM, -0700|
|"yyyyy.MMMMM.dd GGG hh:mm aaa"|02001.July.04 AD 12:08 PM|
|"EEE, d MMM yyyy HH:mm:ss Z"|Wed, 4 Jul 2001 12:08:56 -0700|
|"yyMMddHHmmssZ"|010704120856-0700|
|"yyyy-MM-dd'T'HH:mm:ss.SSSZ"|2001-07-04T12:08:56.235-0700|

**2. 输出不同时区的时间**

由于不同的时区的时间是不一样的，甚至同一个国家的不同城市的时间都可能不一样，所以，在Java中获取时间时，要重点关注时区问题。

默认情况下，如果不指明时区，那么在创建日期时，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获得当前时间的原因。

如何在Java代码中获取不同时区的时间呢？SimpleDateFormat就可以实现这个功能：
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
sdf.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));
System.out.println(sdf.format(Calendar.getInstance().getTime()));
```

以上代码转换的结果是2018-11-24 21:00:00，即中国的时间是11月25日的13点，而美国洛杉矶的时间比中国北京的时间慢了16个小时（还和冬夏令时有关系，这里就不详细展开了）。

如果读者感兴趣，则还可以尝试打印一下美国纽约时间（America/New_York）。纽约时间是2018-11-25 00:00:00，纽约时间比北京时间早了13个小时。

当然，这不是显示其他时区的唯一方法，本节主要为了介绍SimpleDateFormat，其他方法暂不介绍。

**18.4.2 SimpleDateFormat线程
