### 第6章 基本数据类型
#### 6.1 基本类型

基本类型（或者叫作内置类型）是Java中不同于类（Class）的特殊类型，它们是编程中使用最频繁的类型。

Java是一种强类型语言，第一次声明变量时必须说明数据类型，第一次变量赋值称为变量的初始化。

Java的基本类型共有8种，可以分为三类：
- 字符类型。
- 布尔类型。
- 数值类型。

数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double：

- 字符类型：char。
- 布尔类型：boolean。
- 数值类型：byte、short、int、long、float、double。

特别需要注意的是，虽然String在日常开发中也经常使用，但是String不是基本类型，而是引用类型。

Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。

实际上，Java还存在另外一种基本类型void，不过我们无法直接对它们进行操作。

1. **使用基本数据类型的好处**

我们都知道在Java中，新创建的对象是存储在堆里的（不考虑JIT优化的情况下），通过栈中的引用来使用这些对象。所以，对象本身来说是比较消耗资源的。

对于经常用到的类型，如int等，如果我们每次使用这种变量时都新建一个Java对象，就会比较笨重。所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，它们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。

2. **整型的取值范围**

Java中的整型主要包含byte、short、int和long四种，表示的数字范围也是从小到大。之所以表示范围不同，主要和它们存储数据时所占的字节数有关。

注：1字节 = 8位（bit）。Java中的整型属于有符号数。

8 bit可以表示的数字：

- 最小值：10000000（-128）。

- 最大值：01111111（127）。

整型的取值如下：

- byte：byte用1字节存储，范围为-128（-2⁷）到127（2⁷-1），在初始化变量时，byte类型的默认值为0。

- short：short用2字节存储，范围为-32768（-2¹⁵）到32767（2¹⁵-1），在初始化变量时，short类型的默认值为0。 

- int：int用4字节存储，范围为-2147483648（-2³¹）到2147483647（2³¹-1），在初始化变量时，int类型的默认值为0。 

- long：long用8字节存储，范围为-9223372036854775808（-2⁶³）到9223372036854775807（2⁶³-1），在初始化变量时，long类型的默认值为0L或0l，也可直接写为0。 

3. **超出范围怎么办**

在整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致结果超出表示范围，即溢出。比如以下代码：

```java

int i = Integer.MAX_VALUE;
int j = Integer.MAX_VALUE;
int k = i + j;
System.out.println("i (" + i + ") + j (" + j + ") = k (" + k + ")");
```
输出结果：i(2147483647)+j(2147483647)=k(-2)。

这就是发生了溢出，溢出时并不会抛出异常，也没有任何提示。

所以，在程序中，使用同类型的数据进行运算时，一定要注意数据溢出的问题。

#### 6.2 浮点数
我们知道，计算机中的数字都是通过二进制数存储和运算的，对于十进制整数转换为二进制整数，采用“除2取余，逆序排列”法。

具体做法如下：
- 用2整除十进制整数，可以得到一个商和余数。
- 再用2去除商，又会得到一个商和余数，如此循环，直到商小于1时为止。 
- 把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

例如，把127转换成二进制数，做法如图6-1所示。

127 / 2 = 63 余 1
63 / 2 = 31 余 1
31 / 2 = 15 余 1
15 / 2 = 7 余 1
7 / 2 = 3 余 1
3 / 2 = 1 余 1
1 / 2 = 0 余 1  → 1111111

那么，十进制小数转换成二进制小数，又该如何计算呢？

![image](https://github.com/user-attachments/assets/cfe49684-4f69-49e5-8e63-6470e445ecf3)


十进制小数转换成二进制小数采用“乘2取整，顺序排列”法。

具体做法如下：
- 用2乘十进制小数，可以得到积。
- 将积的整数部分取出，再用2乘余下的小数部分，又得到一个积。
- 再将积的整数部分取出，如此循环，直到积中的小数部分为零，此时0或1为二进制数的最后一位，或者达到所要求的精度为止。


例如，将0.625转成二进制数，如图6-2所示。

0.625 × 2 = 1.25 整数部分 1

0.25 × 2 = 0.5 整数部分 0

0.5 × 2 = 1.0 整数部分 1  → 0.101



但是0.625是一个特例，用同样的算法，计算0.1对应的二进制数是多少，如图6-3所示。

0.1 × 2 = 0.2 整数部分 0

0.2 × 2 = 0.4 整数部分 0

0.4 × 2 = 0.8 整数部分 0

0.8 × 2 = 1.6 整数部分 1

0.6 × 2 = 1.2 整数部分 1

0.2 × 2 = 0.4 整数部分 0

0.4 × 2 = 0.8 整数部分 0

0.8 × 2 = 1.6 整数部分 1

0.6 × 2 = 1.2 整数部分 1

0.2 × 2 = 0.4 整数部分 0

……  → 0.000110011001100……



![image](https://github.com/user-attachments/assets/74e890e8-d8d4-4171-8c34-5583886bd73b)



我们发现，0.1的二进制数中出现了无限循环的情况，也就是(0.1)10=(0.000110011001100…)2。

在这种情况下，计算机就无法用二进制数精确地表示0.1了。

所以，为了解决部分小数无法使用二进制数精确表示的问题，于是就有了IEEE 754规范。IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来使用最广泛的浮点数运算标准，为许多CPU与浮点运算器所采用。

浮点数和小数并不是完全一样的，计算机中小数的表示法有定点和浮点两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数表示实数的近似值。

IEEE 754规定了4种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43bit以上，很少使用）与延伸双精确度（79bit以上，通常以80位实现）。

其中最常用的就是32位单精度浮点数和64位双精度浮点数。

单精度浮点数在计算机存储器中占用4字节（32 bit），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。

相比单精度浮点数，双精度浮点数（double）使用64位（8字节）来存储一个浮点数。

需要注意的是，IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。

一个浮点数a由两个数m和e来表示：a = m × bᵉ。

在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1 ）。

如果m的第一位是非0整数，则称m是规格化的。有一些描述使用一个单独的符号位（s代表+或者-）来表示正负，这样m必须是正的。e是指数。

规格化又叫作规格化数，是一种表示浮点数的规格化的表示方法，经过规格化的浮点数叫作规格化数。

最后，由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。建议使用BigDecimal或者Long（单位为分）来表示金额。

#### 6.3 Java中负数的绝对值并不一定是正数

绝对值是指一个数在数轴上所对应的点到原点的距离。在数学领域，正数的绝对值是这个数本身，负数的绝对值应该是其相反数。

在Java中，想要获得一个数字的绝对值，可以使用java.lang.Math中的abs方法，这个类共有4个重载的abs方法，分别是：
```java
public static int abs(int a) {
    return (a < 0)? -a : a;
}

public static long abs(long a) {
    return (a < 0)? -a : a;
}

public static float abs(float a) {
    return (a <= 0.0F)? 0.0F - a : a;
}

public static double abs(double a) {
    return (a <= 0.0D)? 0.0D - a : a;
}
```
以上4个方法分别返回int、long、float、double类型的绝对值，方法中的逻辑也简单，无非就是遇到非负数就直接返回，遇到负数就取相反数返回。

基于以上知识，我们经常会直接使用Math.abs来对一个数字取绝对值。

比如，我们基于订单号实现分库分表，但订单号是字符串类型，我们需要取得这个字符串的hashCode，因为hashCode可能是负数，所以对hashCode取绝对值，再用这个值对分表数取模：
```java
Math.abs(orderId.hashCode()) % 1024;
```
但是，上面的逻辑是有问题的！

因为在极特殊情况下，上面的代码会得到一个负数的值。

这种极特殊情况就是当hashCode是Integer.MIN_VALUE时，即整数能表达的最小值时。下面通过代码进行验证：
```java
public static void main(String[] args) {
    System.out.println(Math.abs(Integer.MIN_VALUE));
}
```
执行以上代码，得到的结果如下：
-2147483648

很明显，这是个负数！

为什么会这样呢？

这要从Integer的取值范围说起，int的取值范围是-2³¹至2³¹-1，即-2147483648至2147483647。

当我们使用abs取绝对值时，取得-2147483648的绝对值是2147483648。

但是，2147483648大于2147483647，即超过了int的取值范围。这时就会发生越界。

2147483647用二进制的补码表示如下：
01111111 11111111 11111111 11111111

这个数+1后得到如下值：
10000000 00000000 00000000 00000000

这个二进制值就是-2147483648的补码。

这种情况发生的概率很低，只有当要取绝对值的数字是-2147483648时，得到的数字才是一个负数。

如何解决这个问题呢？

既然认为越界导致最终结果变成了负数，那么就解决越界的问题。在取绝对值之前，把这个int类型的值转成long类型，这样就不会出现越界了。

例如，将分表逻辑修改为：
```java
Math.abs((long)orderId.hashCode()) % 1024;
```
就万无一失了。

执行以下代码：
```java
public static void main(String[] args) {
    System.out.println(Math.abs((long)Integer.MIN_VALUE));
}
```
得到的结果就是：
2147483648

一定要记得，对long类型的数值取绝对值其实也可能存在这个情况，只不过发生的概率就更低了。 

### 6.4 基本类型的包装类

在Java中，基本类型都有对应的包装类。包装类的作用主要有以下几点：

- **集合框架的需求**：Java的集合框架，如ArrayList、HashMap等，只能存储对象类型的数据，不能直接存储基本类型。所以需要将基本类型包装成对象类型，才能放入集合中。

- **方便对象操作**：包装类提供了一系列方法，方便对基本类型数据进行操作，如类型转换、格式化输出等。例如，Integer类的`parseInt`方法可以将字符串转换为整数。



Java中8种基本类型对应的包装类如下：
|基本类型|包装类|
| ---- | ---- |
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|
|boolean|Boolean|

#### 6.4.1 装箱与拆箱
- **装箱**：是指将基本类型转换为对应的包装类对象。在Java 5.0之前，需要手动创建包装类对象来实现装箱，例如：
```java
Integer i = new Integer(10);
```
Java 5.0引入了自动装箱机制，现在可以直接将基本类型赋值给包装类对象，例如：
```java
Integer i = 10; // 自动装箱
```
- **拆箱**：是指将包装类对象转换为基本类型。以前需要调用包装类的`xxxValue`方法（如`intValue`、`doubleValue`等）来实现拆箱，例如：
```java
Integer i = new Integer(10);
int num = i.intValue();
```
Java 5.0引入自动拆箱后，可以直接将包装类对象赋值给基本类型变量，例如：
```java
Integer i = 10;
int num = i; // 自动拆箱
```

#### 6.4.2 包装类的缓存机制
部分包装类为了提高性能，实现了缓存机制。以Integer为例，在`-128`到`127`之间的整数会被缓存起来。当通过自动装箱创建这个范围内的Integer对象时，实际上返回的是缓存中的对象，而不是新建对象。例如：
```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // 输出true，因为100在缓存范围内，a和b指向同一个缓存对象

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // 输出false，因为128不在缓存范围内，c和d是不同的对象
```
Byte、Short、Long等包装类也有类似的缓存机制，范围一般是`-128`到`127`；Character缓存范围是`0`到`127`。Boolean包装类则缓存了`true`和`false`两个对象。

#### 6.5 基本数据类型的默认值
在Java中，基本数据类型在不同场景下有默认值：
- **成员变量**：当基本数据类型作为类的成员变量时，如果没有进行显式初始化，会有默认值。具体如下：
    - byte、short、int、long的默认值是`0`。
    - float、double的默认值是`0.0`。
    - char的默认值是`\u0000`，即空字符。
    - boolean的默认值是`false`。
- **局部变量**：基本数据类型作为局部变量时，必须显式初始化才能使用，否则编译器会报错。例如：
```java
public class Test {
    int memberVariable; // 成员变量，默认值为0
    public void method() {
        int localVariable; // 局部变量，未初始化不能使用
        // System.out.println(localVariable); // 编译报错
    }
}
```

#### 6.6 基本数据类型的转换
Java中基本数据类型之间可以进行转换，分为自动类型转换和强制类型转换：
- **自动类型转换**：当把表示范围小的基本数据类型赋值给表示范围大的基本数据类型时，会发生自动类型转换。例如：
```java
byte b = 10;
int i = b; // 自动类型转换，byte自动转换为int
```
自动类型转换的规则是：byte -> short -> int -> long -> float -> double ，char -> int。
- **强制类型转换**：当把表示范围大的基本数据类型赋值给表示范围小的基本数据类型时，需要进行强制类型转换，格式为`(目标类型) 要转换的值`。例如：
```java
int i = 100;
byte b = (byte)i; // 强制类型转换，可能会丢失精度或数据溢出
```
需要注意的是，强制类型转换可能会导致数据丢失或精度损失。例如，将较大的整数强制转换为byte类型时，可能会因为超出byte的表示范围而得到意外结果。

**小结**
Java的基本数据类型是编程中基础且重要的部分。了解基本类型的分类、取值范围、运算特点、包装类的使用以及类型转换规则等知识，有助于写出更健壮、高效的Java代码。在实际开发中，要根据具体场景合理选择基本数据类型，并注意避免因类型相关问题导致的错误。 
