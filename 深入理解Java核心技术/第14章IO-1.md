### 第14章 I/O
#### 14.1 什么是I/O流，如何分类

Java的核心库java.io提供了全面的I/O接口。所谓I/O其实是Input和Output的缩写，在Java中，I/O指的是通过数据流、序列化和文件系统提供系统的输入和输出。

Java中的I/O是以流为基础实现输入/输出的，流是一个很形象的概念，当程序需要读取数据（Input）时，就会开启一个通向数据源的流，这个数据源可以是文件、内存，或者网络连接；当程序需要写入数据（Output）时，就会开启一个通向目的地的流。数据好像在其中“流”动一样。所以，我们会经常听到I/O流这样的描述。

Java中的I/O是一个非常庞大的体系，下面介绍I/O流的分类。

I/O流的分类方式有许多种，按照流的方向可以分为输入流和输出流；按照数据传输的单位又可以划分为字节流和字符流。

1. **输入流与输出流**

对于输入和输出，需要有一个参照物，我们在描述流的方向时，可以把外部输入设备作为参照物。

当程序要从外部输入设备，如文件、网络等读取数据时，流的方向是外部输入设备到运行程序，这种方向的I/O流我们称之为输入流。

当程序要把数据写入外部输入设备时，流的方向是运行程序到外部设备，这种方向的I/O流我们称之为输出流，如图14-1所示。

![image](https://github.com/user-attachments/assets/89e98af0-058c-4bfa-88d6-35c46e32789b)


2. **字节与字符**

I/O流的作用是传输数据，根据数据传输的单位可以把I/O流分为字节流和字符流。那么什么是字节和字符呢？

在计算机中，数据的最小单位是比特（bit），比特是信息技术中最基本的存储单元，二进制中的一位就是1 bit。

但是因为比特太小了，所以我们通常在计量数据容量时，会采用字节（Byte）这种计量单位。在大多数计算机系统中，一个字节（Byte）是一个8位（bit）长的数据单位，所以Byte和bit之间的换算关系是1 Byte = 8 bit。

通常我们也把Byte缩写成B，随着存储容量越来越大，我们也经常使用KB、MB、GB、TB等表示数据容量。

除了以字节为传输单位，还有一种常见的传输方式——传输字符。

字符（Char，Character）是计算机中使用的字母、数字、字和符号，比如A、B、1、$等。

一般情况下，一个英文字符占用1字节，一个汉字字符占用2字节。这只是通常的情况，因为在不同的编码方式下，字符占用的字节数是不一定的，关于这部分知识，我们在第23章中会重点介绍。

因为一个字符至少要占用1字节，所以字符是比字节更大的一种计量单位。

3. **字节流与字符流**

在I/O流中，传输的数据类型是字节（Byte）的就是字节流，传输的数据类型是字符（Char）的就是字符流。

在Java中，操作字节类型的数据的主要操作类是OutputStream和InputStream的子类，操作字符类型的数据的主要操作类是Reader和Writer的子类。

如果按照流向来区分这四种类，那么InputStream和Reader是输入流，而OutputStream和Writer是输出流，如表14-1所示。

| I/O流分类 | 字节流 | 字符流 |
| ---- | ---- | ---- |
| 输入流 | InputStream | Reader |
| 输出流 | OutputStream | Writer |

4. **字节流与字符流的互相转换**

在Java的I/O体系中，除了字节流、字符流需要用的这四种I/O相关的类，还存在一组字节流—字符流的转换类。

也就是说，字节流和字符流之间是可以相互转换的，当我们想要把字符流转成字节流时，可以使用OutputStreamWriter；当我们想要把字节流转成字符流时，可以使用InputStreamReader。

OutputStreamWriter：Writer的子类，是字符流通向字节流的桥梁，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。其用法如下：

```java
public static void main(String[] args) throws IOException {
    File f = new File("io.txt");
    OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(f), "UTF-8");
    osw.write("字符转成字节输出");
    osw.close();
}
```

InputStreamReader：Reader的子类，是字节流通向字符流的桥梁，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。其用法如下：

```java
public static void main(String[] args) throws IOException {
    File f = new File("io.txt");
    InputStreamReader inr = new InputStreamReader(new FileInputStream(f), "UTF-8");
    char[] buf = new char[1024];
    int len = inr.read(buf);
    System.out.println(new String(buf, 0, len));
    inr.close();
}
```
#### 14.2 同步/异步与阻塞/非阻塞

当我们在学习I/O的时候，通常会接触同步/异步和阻塞/非阻塞这几个概念，而且经常容易弄混这几个概念之间的关系。到底什么是同步/异步，什么是阻塞/非阻塞，它们之间又有什么区别和联系呢？

当I/O操作发生时，一定是有两方参与的，分别是调用方和被调用方。阻塞与非阻塞描述的是调用方，同步与异步描述的是被调用方。

例如，A调用B：

- 如果是阻塞，那么A在发出调用命令后，要一直等待B返回结果。

- 如果是非阻塞，那么A在发出调用命令后，不需要等待，可以去做自己的事情。

- 如果是同步，那么B在收到A的调用命令后，会立即执行要做的事，A的本次调用可以得到结果。

- 如果是异步，那么B在收到A的调用命令后，不保证会立即执行要做的事，但是保证会做，B在做好了之后会通知A。A的本次调用得不到结果，但是B执行完要做的事之后会通知A。

因为同步/异步与阻塞/非阻塞描述的对象不同，所以这二者之间是没有必然关系的。也就是说，同步不一定阻塞，异步也不一定非阻塞。

举个简单的例子，老张烧水的过程可以分成以下4种情况：

（1）老张把普通水壶放到火炉上，一直在水壶旁等着水烧开（同步阻塞）。

（2）老张把普通水壶放到火炉上，去客厅看电视，时不时去厨房看一下水烧开没有（同步非阻塞）。

（3）老张把响水壶放到火炉上，一直在水壶旁等着水烧开（异步阻塞）。

（4）老张把响水壶放到火炉上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶（异步非阻塞）。

在上面的例子中，老张就是调用方，水壶就是被调用方，（1）和（2）的区别是，调用方在得到返回结果之前所做的事情不一样；（1）和（3）的区别是，被调用方对于烧水的处理不一样。

只不过通常很少存在异步且阻塞的场景，所以很多人误以为同步一定是阻塞的、异步一定是非阻塞的。

#### 14.3 Linux的五种I/O模型
Java中提供的I/O有关的API，在处理文件时，其实是依赖操作系统层面的I/O操作实现的。比如在Linux 2.6以后，Java中的NIO和AIO都是通过epoll实现的，而在Windows中，AIO是通过IOCP实现的。

可以把Java中的BIO、NIO和AIO理解为Java语言对操作系统的各种I/O模型的封装。程序员在使用这些API时，不需要关心操作系统层面的内容，也不需要根据不同操作系统编写不同的代码，只需要使用Java的API就可以了。

但是，想要真正地理解Java中的I/O模型，了解操作系统的I/O模型是十分必要的。而要了解操作系统的I/O模型，Linux的I/O模型又是绕不开的话题。

在Linux（UNIX）操作系统中，一共有五种I/O模型，分别是阻塞I/O模型、非阻塞I/O模型、I/O复用模型、信号驱动式I/O模型和异步I/O模型。

我们常说的I/O，指的是文件的输入和输出，但在操作系统层面是如何定义I/O的呢？到底什么样的过程可以叫作一次I/O呢？

以一次磁盘文件的读取为例，我们要读取的文件是存储在磁盘上的，我们的目的是把它读取到内存中。可以把这个步骤简化成把数据从硬件（硬盘）读取到用户空间。

其实真正的文件读取还涉及缓存等细节，这里就不展开讲述了。关于用户空间、内核空间及硬件等的关系可以通过下面钓鱼的例子来理解：

钓鱼时，刚开始鱼是在鱼塘中的，钓鱼动作的最终结束标志是鱼从鱼塘中被我们钓上来并放入鱼篓。其中鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核空间，最终放鱼的鱼篓可以映射成用户空间。一次完整的钓鱼（I/O）操作，是鱼（文件）从鱼塘（硬盘）转移（复制）到鱼篓（用户空间）的过程。

1. **阻塞I/O模型**

这是最传统的一种I/O模型，即在读/写数据过程中会发生阻塞现象。

我们在钓鱼时，有一种方式比较惬意、轻松，那就是坐在鱼竿面前，在这个过程中我们什么也不做，双手一直握着鱼竿，静静地等着鱼咬钩。一旦手上感受到鱼拉扯鱼竿，就把鱼钓起来放入鱼篓，再钓下一条鱼。

映射到Linux操作系统中，这就是一种最简单的I/O模型，即阻塞式I/O模型。阻塞式I/O模型是最简单的I/O模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。如果条件满足，则进行下一步操作。阻塞I/O模型如图14-2所示。

应用进程通过系统调用recvfrom接收数据，但由于内核还未准备好数据报，应用进程就会阻塞，直到内核准备好数据报，recvfrom完成数据报的复制工作，应用进程才能结束阻塞状态。

这种最简单的“钓鱼”方式对于钓鱼的人来说，不需要特制的鱼竿，拿一根够长的木棍就可以悠闲地钓鱼了（实现简单），缺点是比较耗费时间，适合钓鱼人对鱼的需求量小的场景（并发低，时效性要求低）。

![image](https://github.com/user-attachments/assets/29517117-3238-4100-817d-db297d6eb549)


2. **非阻塞I/O模型**

钓鱼的时候，在等待鱼咬钩的过程中，我们可以做一些别的事情，比如玩一会儿手机游戏等。但是，我们要时不时地看一下鱼竿，一旦发现有鱼上钩了，就把鱼钓上来。

映射到Linux操作系统中，这就是非阻塞I/O模型。应用进程与内核交互，目的未达到之前，不再一味地等待，而是直接返回。然后通过轮询的方式，不停地询问内核数据有没有准备好。如果某一次轮询发现数据已经准备好了，那么就把数据复制到用户空间。非阻塞I/O模型如图14-3所示。

应用进程通过recvfrom不停地与内核交互，直到内核准备好数据。如果没有准备好数据，则内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间间隔，进程可以做别的事情。

这种模型和阻塞式I/O模型相比，所使用的工具没有什么变化，但是“钓鱼”时可以做一些其他事情，提高了时间的利用率。

![image](https://github.com/user-attachments/assets/19856fc3-6e3f-4b9a-9a41-7732417a0e8d)


3. **信号驱动I/O模型**

钓鱼时，为了避免自己一遍遍地查看鱼竿，我们可以给鱼竿安装一个报警器，当有鱼咬钩时立刻报警，我们在收到报警后，就把鱼钓起来。

![image](https://github.com/user-attachments/assets/e9bf6ba3-03d7-48b9-b7db-ada6a5578e75)


映射到Linux操作系统中，这就是信号驱动I/O模型。应用进程在读取文件时通知内核，当某个Socket事件发生时，请向我发一个信号。在应用进程收到信号后，信号对应的处理函数会进行后续的处理。信号驱动I/O模型如图14-4所示。

![image](https://github.com/user-attachments/assets/679dcd17-bdf4-4943-8073-24a56426c315)


应用进程预先向内核注册一个信号处理函数，然后用户进程不阻塞直接返回，当内核数据准备就绪时会发送一个信号给进程，用户进程在信号处理函数中把数据复制到用户空间。

这种方式和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人可以在鱼咬钩之前做别的事情，等着报警器响就行了。

4. **I/O复用模型**

我们钓鱼时，为了保证可以在最短的时间钓到最多的鱼，会同时摆放多个鱼竿，哪个鱼竿有鱼咬钩了，我们就把哪个鱼竿上面的鱼钓起来。

映射到Linux操作系统中，这就是I/O复用模型。多个进程的I/O可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据复制到用户空间。I/O复用模型如图14-5所示。

I/O多路转接是多了一个select函数，多个进程的I/O可以注册到同一个select上，当用户进程调用该select时，select会监听所有注册好的I/O，如果所有被监听的I/O需要的数据都没有准备好，那么select调用进程会阻塞。当任意一个I/O所需的数据准备好之后，select调用就会返回，然后进程通过recvfrom实现数据复制。

这里并没有向内核注册信号处理函数，所以，I/O复用模型并不是非阻塞的。进程在发出select后，要等select监听的所有I/O操作中至少有一个需要的数据准备好，才会有返回值，并且需要再次发送请求去执行文件的复制。

这种增加鱼竿的方式，可以有效地提升钓鱼的效率。

为什么以上四种模式都是同步的？

阻塞I/O模型、非阻塞I/O模型、I/O复用模型和信号驱动I/O模型都是同步的I/O模型，因为无论以上哪种模型，真正的数据复制过程都是同步进行的。

信号驱动难道不是异步的吗？

基于信号驱动I/O模型，内核是在数据准备好之后通知进程的，然后进程再通过recvfrom操作进行数据复制。我们可以认为数据准备阶段是异步的，但数据复制操作是同步的。所以，整个I/O过程也不能认为是异步的。

还是以钓鱼为例，钓鱼过程可以拆分为以下两个步骤：

（1）鱼咬钩（数据准备）。

（2）把鱼钓起来放进鱼篓中（数据复制）。

无论以上提到的哪种钓鱼方式，第二步都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。

5. **异步I/O模型**

我们钓鱼时使用了一种高科技钓鱼竿，即全自动钓鱼竿，可以自动感应鱼上钩、自动收竿，更厉害的是可以自动把鱼放进鱼篓中，然后通知我们鱼已经钓到了，可以继续钓下一条鱼了。

映射到Linux操作系统中，这就是异步I/O模型。应用进程把I/O请求传给内核后，完全由内核去完成文件的复制。内核完成相关操作后，会发送信号告诉应用进程本次I/O操作已经完成。异步I/O模型如图14-6所示。

用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后开始等待数据准备，数据准备好以后，直接把数据复制到用户控件，然后通知进程本次I/O操作已经完成。

这种“钓鱼”方式无疑是最省事的。

![image](https://github.com/user-attachments/assets/7779a3a6-2b90-4c62-befe-c33c943ff08a)


6. **五种I/O模型对比**

介绍了五种I/O模型的特点之后，我们把它们放到一起对比一下，如图14-7所示。

|  | 阻塞I/O | 非阻塞I/O | I/O复用 | 信号驱动I/O | 异步I/O |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 发起 | 阻塞 | 检查<br>检查<br>检查<br>检查<br>检查<br>检查<br>阻塞 | 检查<br>阻塞<br>就绪<br>发起<br>阻塞 | 通知<br>发起<br>阻塞 | 发起 |
| 等待数据 |  |  |  |  | 通知 |
| 完成 | 完成 | 完成 | 完成 | 完成 |  |
第一阶段处理不同，第二阶段处理相同（阻塞于recvfrom调用） 处理两个阶段 


![image](https://github.com/user-attachments/assets/5916c8a8-9b0c-4983-832b-b9459bc7c082)
