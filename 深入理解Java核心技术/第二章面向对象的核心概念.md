
### 第2章 面向对象的核心概念

#### 2.1 重载和重写

重载（Overloading）和重写（Overriding）是Java中比较重要的两个概念。本节列举两个实际的例子，说明到底什么是重写和重载。

1. **定义**

    - **重载**：在同一个类中，多个函数或者方法有同样的名称，但是参数列表不同，这样的同名不同参数的函数或者方法，互相称之为重载函数或者重载方法。
    
    - **重写**：在Java的子类与父类中，有两个名称和参数列表都相同的方法，由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

2. **重载的例子**

示例如下：

```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }
    // 重载方法
    public void bark(int num){
        for(int i=0; i<num; i++)
            System.out.println("woof ");
    }
}
```

上面的代码中定义了两个bark方法，一个是没有参数的bark方法，另一个是包含一个int类型参数的bark方法。这两个方法就是重载方法，因为它们的方法名相同、参数列表不同。


在编译期，编译器可以根据方法签名（方法名和参数）确定具体哪个bark方法被调用。

方法重载需要满足以下条件和要求：

- 被重载的方法必须改变参数列表。

- 被重载的方法可以改变返回类型。

- 被重载的方法可以改变访问修饰符。

- 被重载的方法可以声明新的或更广的检查异常。

- 方法能够在同一个类中或者在一个子类中被重载。

3. **重写的例子**

下面是一个重写的例子，读者看完代码之后不妨猜测一下输出结果：

```java

class Dog{
    public void bark(){
        System.out.println("woof ");
    }
}
class Hound extends Dog{
    public void sniff(){
        System.out.println("sniff ");
    }
    public void bark(){
        System.out.println("bowl");
    }
}
public class OverridingTest{
    public static void main(String [] args){
        Dog dog = new Hound();
        dog.bark();
    }
}
```
输出结果如下：

bowl

在上面的例子中，我们分别在父类、子类中都定义了bark方法，并且它们都是无参方法，这种情况就是方法重写，即子类Hound重写了父类Dog中的bark方法。

在测试的main方法中，dog对象被定义为Dog类型。

在编译期，编译器会检查Dog类中是否有可访问的bark()方法，只要其中包含bark()方法，那么就可以编译通过。

在运行期，Hound对象被“new”出来，并赋值给dog变量，这时，JVM明确地知道dog变量指向的是Hound对象的引用。所以，当dog调用bark()方法时，就会调用Hound类中定义的bark()方法。这就是所谓的动态多态性。

方法重写需要满足以下条件和要求：

- 参数列表必须完全与被重写方法的参数列表相同。

- 返回类型必须完全与被重写方法的返回类型相同。

- 访问级别的限制性一定不能比被重写方法的限制性强。

- 访问级别的限制性可以比被重写方法的限制性弱。

- 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常有更广泛的检查异常。


- 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）。

- 不能重写被标示为final的方法。

- 如果不能继承一个方法，则不能重写这个方法。


#### 2.2 多态

在1.2节中，我们介绍了面向对象的封装、继承和多态三个基本特征，并且分别举例说明了封装和继承。本节对多态展开介绍。

##### 2.2.1 什么是多态

我们先基于所有的编程语言介绍什么是多态及多态的分类，然后重点介绍Java中的多态。

多态（Polymorphism）指为不同数据类型的实体提供统一的接口，或者使用一个单一的符号来表示多种不同的类型。一般情况下，可以把多态分成以下几类。


1. **特设多态**

特设多态是程序设计语言的一种多态，多态函数有多个不同的实现，依赖于其实参而调用相应版本的函数。

2.1节介绍过的函数重载是特设多态的一种，除此之外，运算符重载也是特设多态的一种。

2. **参数多态**

在程序设计语言与类型论中，参数多态是指声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。

参数多态其实也有很广泛的应用，比如Java中的泛型就是参数多态的一种。参数多态另一个应用比较广泛的地方就是函数式编程。

3. **子类型**

在面向对象程序设计中，当计算机程序运行时，相同的消息可能会发送给多个不同类别的对象，而系统依据对象的所属类别，触发对应类别的方法，产生不同的行为。

这种子类型多态其实就是Java中常见的多态，下面我们针对Java中的这种子类型多态展开介绍。

##### 2.2.2 Java中的多态


Java中多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

Java中的多态其实是一种运行期的状态。为了实现运行期的多态，或者说动态绑定，需要满足三个条件：

- 有类继承或者接口实现。

- 子类要重写父类的方法。

- 父类的引用指向子类的对象。

通过一段代码解释一下：
```java
public class Parent{
    public void call(){
        sout("im Parent");
    }
}
public class Son extends Parent{// 有类继承或者接口实现
    public void call(){// 子类要重写父类的方法
        sout("im Son");
    }
}
public class Daughter extends Parent{// 有类继承或者接口实现
    public void call(){// 子类要重写父类的方法
        sout("im Daughter");
    }
}
public class Test{
    public static void main(String[] args){
        Parent p = new Son(); // 父类的引用指向子类的对象
        Parent p1 = new Daughter(); // 父类的引用指向子类的对象
    }
}
```

这样就实现了多态，同样是Parent类的实例，p.call调用的是Son类的实现、p1.call调用的是Daughter的实现。

有人说，你自己定义时不就已经知道p是son、p1是Daughter了吗？但是，有些时候用到的对象并不是自己声明的。

比如Spring中的基于IoC创建的对象，在使用时就不知道这个对象是谁，或者说你可以不用关心这个对象是谁，而是根据具体情况而定。

IoC是Inversion of Control的缩写，中文翻译成“控制反转”，它是一种设计思想，意味着将你设计好的对象交给容器控制，而不是在对象内部直接控制。

换句话说，当我们使用Spring框架时，对象是Spring容器创建出来并由容器进行管理的，只需要使用就行了。

**静态多态**

上面说的多态是一种运行期的概念。还有一种说法，认为多态还分为动态多态和静态多态。

上面提到的那种动态绑定被认为是动态多态，因为只有在运行期才知道真正调用的是哪个类的方法。

还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为它需要在编译期决定具体调用哪个方法。

结合2.1节的内容，我们总结一下重载和重写两个概念：

（1）重载是一个编译期概念，重写是一个运行期概念。

（2）重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。

（3）重写遵循所谓“运行期绑定”，即在程序运行时，根据引用变量所指向的实际对象的类型来调用方法。

（4）Java中的方法重写是Java多态（子类型）的实现方式，而Java中的方法重载是特设多态的一种实现方式。


#### 2.3 继承与实现

我们知道，继承可以使用现有类的所有功能，并在无须重新编写原来的类的情况下对这些功能进行扩展。这种派生方式体现了传递性。

在Java中，除了继承，还有一种体现传递性的方式叫作实现。那么，这两种方式有什么区别呢？

继承和实现的明确定义和区别如下：

- **继承（Inheritance）**：如果多个类的某个部分的功能相同，那么可以抽象出一个类，把它们的相同部分都放到父类里，让它们都继承这个类。
- **实现（Implement）**：如果多个类处理的目标是一样的，但是处理的方法、方式不同，那么就定义一个接口，也就是一个标准，让它们都实现这个接口，各自实现自己具体的处理方法。

继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要复用，而实现的根本原因是需要定义一个标准。

在Java中，类的继承使用了extends关键字，而接口的实现使用了implements关键字。

简单地说，同样是一台汽车，既可以是电动车，也可以是汽油车，还可以是油电混合汽车，只要遵守不同的标准就行，但是一台车只能属于一个品牌、一个厂商。示例代码如下：

```java
class Car extends Benz implements GasolineCar, ElectroCar{
}
```

上述代码中我们定义了一辆汽车，它实现了电动车和汽油车两个标准，但是它属于奔驰这个品牌，我们可以最大限度地遵守标准，并且复用奔驰车所有已有的一些功能组件。

另外，在接口中只能定义全局常量（static final）和无实现的方法（Java 8以后可以有default方法）；而在继承中可以定义属性方法、变量和常量等。


#### 2.4 多继承
特别需要注意的是，Java中支持一个类同时实现多个接口，但是不支持同时继承多个类（但是这个问题在Java 8之后也不是绝对的了）。

为什么Java中不支持同时继承多个类呢？

1. **多继承简介**

对于一个类只有一个父类的情况，我们叫作单继承。而一个类同时有多个父类的情况叫作多继承。

在Java中，一个类只能通过extends关键字继承另一个类，不允许多继承。但是，在其他面向对象语言中是有可能支持多继承的。

例如C++就是支持多继承的，主要是因为编程的过程是对现实世界的一种抽象，而在现实世界中，确实存在着需要多继承的情况。比如维基百科中关于多继承举了一个例子：

例如，可以创造一个“哺乳类动物”类别，拥有进食、繁殖等功能；然后定义一个子类型“猫”，它可以从父类继承上述功能。但是，“猫”还可以作为“宠物”的子类，拥有一些宠物独有的能力。

所以，有些面向对象语言是支持多重继承的。 



### 2.4 多继承

但是，多年以来，多重继承一直都是一个敏感的话题，反对者指它增加了程序的复杂性与含糊性。

#### 2. 菱形继承问题

假设类B和类C都继承了相同的类A，类D通过多重继承机制继承了类B和类C，如图2-1所示。

![image](https://github.com/user-attachments/assets/2f2c0bec-d562-45fb-bd2f-867fcd470b18)


![图2-1](此处原书有图，展示A继承出B和C，B和C又继承出D的菱形结构)

因为类D同时继承了类B和类C，并且类B和类C又同时继承了类A，那么，类D就会因为多重继承而继承了两份来自类A中的属性和方法。

在使用类D时，如果想调用一个定义在类A中的方法时，就会出现歧义。

因为这种继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。


而C++为了解决菱形继承问题，又引入了虚继承。

因为支持多继承，所以引入了菱形继承问题，又因为要解决菱形继承问题，所以又引入了虚继承。而经过分析，我们发现其实真正想要使用多继承的情况并不多。

所以，在Java中，不允许“实现多继承”，即一个类不允许继承多个父类。但是Java允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8以前），这就避免了C++中多继承的歧义问题。

但是，在Java 8中支持了默认函数（Default Method）之后，“Java不支持多继承”就不是那么绝对了。

虽然我们还是无法使用extends同时继承多个类，但是因为有了默认函数，我们就有可能通过implements从多个接口中继承多个默认函数。

那么，如何解决这种情况带来的菱形继承问题呢？

这个问题在23.2节中单独介绍。


### 2.5 组合与继承
前面我们讲解了面向对象的三个特征，并且通过对继承和实现的学习，了解了继承可以帮助我们实现类的复用。

所以，很多程序员在需要复用一些代码时很自然地会使用类的继承的方式。

但是，只要遇到想要复用的场景就直接使用继承，这样做是不对的。长期、大量地使用继承会给代码带来很高的维护成本。

本节将介绍一种新的可以帮助我们复用的概念——组合，通过学习组合和继承的概念及区别，从多方面分析在写代码时如何在这两者中进行选择。

#### 1. 面向对象的复用技术

下面简单介绍面向对象的复用技术。

复用性是面向对象技术带来的潜在好处之一。如果运用得当，那么复用性可以帮助我们节省很多开发时间、提升开发效率。但是，如果复用性被滥用，就可能产生很多难以维护的代码。

作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承、组合和代理三种具体的表现形式。本节将重点介绍继承复用和组合复用。

#### 2. 继承复用

继承是类与类或者接口与接口之间最常见的一种关系。继承是一种is - a的关系，如图2-2所示。

is - a：表示“是一个”的关系。

![图2-2](此处原书有图，展示Class A到Class B 、狗到哈士奇的继承关系)

![image](https://github.com/user-attachments/assets/30e49d13-6618-418e-bfe5-8c310d74c260)


#### 3. 组合

组合（Composition）体现的是整体与部分之间拥有的关系，即has - a的关系，如图2-3所示。

has - a：表示“有一个”的关系。

![image](https://github.com/user-attachments/assets/e3f3d631-24a1-4515-bb98-f621d8b7778a)


![图2-3](此处原书有图，展示Class A到Class B 、发动机到汽车的组合关系)

#### 4. 组合与继承的区别和联系


首先，在类的关系确定的时间点上，组合和继承是有区别的：

- **继承**：因为在写代码时就要指名具体继承哪个类，所以在编译期就确定了类的关系。并且从基类继承的实现是无法在运行期动态改变的，因此降低了应用的灵活性。

- **组合**：在写代码时可以采用面向接口编程，所以类的组合关系一般在运行期确定。

另外，在代码复用方式上也有一定区别：

- 在继承结构中，父类的内部细节对于子类是可见的。所以通常说通过继承的代码复用是一种白盒式代码复用。如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性。

- 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。因为在组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法。

最后，Java中不支持多继承，而组合是没有限制的。就像一个人只能有一个父亲，但是他可以有很多辆车。

#### 5. 优缺点对比

组合关系与继承关系的优缺点对比如表2-1所示。

|组合关系|继承关系|
| ---- | ---- |
|优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立|缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性|
|优点：具有较好的可扩展性|缺点：支持扩展，但是往往以增加系统结构的复杂度为代价|
|优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象|缺点：不支持动态继承。在运行时，子类无法选择不同的父类|
|优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口|缺点：子类不能改变父类的接口|
|缺点：整体类不能自动获得和局部类同样的接口|优点：子类能自动继承父类的接口|
|缺点：当创建整体类的对象时，需要创建所有局部类的对象|优点：当创建子类的对象时，无须创建父类的对象|

#### 6. 如何选择

相信很多人都知道面向对象中有一个比较重要的原则“多用组合，少用继承”，或者说“组合优于继承”。从表2-1中也可以看出，组合确实比继承更加灵活，更有助于代码维护。

在《阿里巴巴Java开发手册》中有一条规定：谨慎使用继承的方式进行扩展，优先使用组合的方式实现。

所以，建议在同样可行的情况下，优先使用组合而不是继承。因为组合更安全、更简单、更灵活、更高效。

注意，并不是说继承就一点用都没有了，前面说的是“在同样可行的情况下”。有一些场景还是需要使用继承的，或者说更适合使用继承。

继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承——《Java编程思想》。

只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is - a的关系时，类B才应该继承类A——Effective Java。



### 2.6 构造函数

构造函数是一种特殊的方法，主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符在创建对象的语句中一起使用。例如：

```java

/**

 * 矩形
 */
class Rectangle {
    /**
     * 构造函数
     */
    public Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
    }
    public static void main (String []args){
        // 使用构造函数创建对象
        Rectangle rectangle = new Rectangle(10,5);
    }
}
```

特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。

构造函数跟一般的实例方法十分相似，但是与其他方法不同，构造器没有返回类型，不会被继承，而且可以有范围修饰符。

构造器的函数名称必须和它所属的类的名称相同，它承担着初始化对象数据成员的任务。

当编写一个可实例化的类时，如果没有专门编写构造函数，在默认情况下，一个Java类中会自动生成一个默认无参构造函数。默认构造函数一般会把成员变量的值初始化为默认值，如int->0、Integer->null。

但是，如果我们手动在某个类中定义了一个有参数的构造函数，那么这个默认的无参构造函数就不会自动添加了，而是需要手动创建。例如：

```java
/**
 * 矩形
 */
class Rectangle {
    /**
     * 构造函数
     */
    public Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
    }
    /**
     * 无参构造函数
     */
    public Rectangle() {
    }
}
```

### 2.7 变量

Java中共有三种变量，分别是类变量、成员变量和局部变量，它们分别保存在JVM的方法区、堆内存和栈内存中。例如：
```java
/**
 * @author Hollis
 */
public class Variables {
    /**
     * 类变量
     */
    private static int a;
    /**
     * 成员变量
     */
    private int b;
    /**
     * 局部变量
     * @param c
     */
    public void test(int c){
        int d;
    }
}
```

在上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。

a作为类变量，保存在方法区中；b作为成员变量，和对象一起保存在堆内存中（不考虑栈上分配的情况）；c和d作为方法的局部变量，保存在栈内存中。

之所以要在这一章节重点介绍这三种变量类型，是因为很多人因为不知道这三种类型的区别，所以不知道它们分别保存在哪里，导致不知道哪些变量需要考虑并发问题。

关于并发问题，会在“并发篇”中重点介绍，这里先简单说明：

因为只有共享变量才会遇到并发问题，所以变量a和b是共享变量，变量c和d是非共享变量。如果遇到多线程场景，那么对于变量a和b的操作是需要考虑线程安全的，而对于变量c和d的操作是不需要考虑线程安全的。 



