### 第8章 字符串
#### 8.1 字符串的不可变性

字符串（String）在Java中特别常用，而且我们经常要在代码中对字符串进行赋值和改变其值的操作。其实字符串有一个很重要的特性，那就是不可变性。为什么我们说字符串是不可变的呢？

首先，我们需要知道什么是不可变对象。

不可变对象是在完全创建后其内部状态保持不变的对象。这意味着，一旦对象被赋值给变量，我们既不能更新引用，也不能通过任何方式改变其内部状态。

可能有的读者会感到疑惑，字符串为什么不可变呢？我的代码中就“改变”了字符串的值，例如：

```java
String s = "abcd";
s = s.concat("ef");
```

上述代码中不就将字符串“abcd”变成了“abcdef”了吗？

虽然字符串的内容看上去从“abcd”变成了“abcdef”，但实际上，我们得到的已经是一个新的字符串了。在堆中重新创建了一个“abcdef”字符串，和“abcd”并不是同一个对象。

所以，一旦一个String对象在内存中被创建出来，它就无法被修改。而且，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。

![image](https://github.com/user-attachments/assets/0a05c1a7-d2cb-4fb1-8558-99bb66293c2a)


如果我们想要一个可修改的字符串，则可以选择StringBuffer或StringBuilder来代替String。

为什么String要设计成不可变的？

在知道了“String是不可变的”之后，读者是不是感到疑惑：为什么要把String设计成不可变的呢？有什么好处呢？

这个问题困扰过很多人，甚至有人直接问过Java的创始人James Gosling。

在一次采访中，James Gosling被问到什么时候应该使用不可变变量，他给出的回答是：

I would use an immutable whenever I can.

他给出这个答案背后的原因是什么呢？是基于哪些方面考虑的呢？

其实，这主要是从缓存、安全性、线程安全和性能等方面考虑的。

1. **缓存**

字符串是使用最广泛的数据结构。创建大量的字符串是非常耗费资源的，所以，Java提供了对字符串的缓存功能，可以大大地节省堆空间。

JVM专门开辟了一部分空间来存储Java字符串，这就是字符串池。

通过字符串池，两个内容相同的字符串变量可以在池中指向同一个字符串对象，从而节省了关键的内存资源。例如：

```java
String s = "abcd";
String s2 = s;
```

![image](https://github.com/user-attachments/assets/84094eca-724f-4cee-9592-8f2258005596)


在上述代码中，s和s2都表示“abcd”，所以它们会指向字符串池中的同一个字符串对象。

之所以可以这么做，主要是因为字符串的不变性。试想一下，如果字符串是可变的，我们一旦修改了s的内容，则必然导致s2的内容也被动地改变了，这显然不是我们想看到的。

2. **安全性**

字符串在Java应用程序中广泛用于存储敏感信息，如用户名、密码、连接的URL、网络连接等。JVM类加载器在加载类时也广泛地使用它。

因此，保护String类不被修改对于提升整个应用程序的安全性至关重要。

当我们在程序中传递一个字符串时，如果这个字符串的内容是不可变的，那么我们就可以相信这个字符串中的内容。

如果字符串的内容是可变的，那么这个字符串的内容就可能随时被修改。这样整个系统就没有安全性可言了。

3. **线程安全**

不可变性会自动使字符串成为线程安全的，因为当从多个线程中访问字符串时，字符串的内容不会被更改。

因此，一般来说，不可变对象可以在同时运行的多个线程之间共享。它们也是线程安全的，因为如果线程更改了值，那么将在字符串池中创建一个新的字符串，而不是修改相同的值。因此，字符串对于多线程来说是安全的。

4. **hashCode缓存**

由于字符串对象被广泛地用作数据结构，所以它们也被广泛地用于Hash实现，如HashMap、HashTable、HashSet等。在对这些Hash实现进行操作时，经常调用hashCode()方法。

不可变性保证了字符串的值不会改变。因此，hashCode()方法在String类中被重写，以方便缓存，这样在第一次hashCode()调用期间计算和缓存Hash值，并从那时起返回相同的值。

在String类中，有以下代码：

```java
private int hash;// this is used to cache hash code.
```

5. **性能**

前面提到的字符串池、hashCode缓存等，都是提升性能的体现。

因为字符串不可变，所以可以使用字符串池缓存以大大节省堆内存。而且还可以提前对hashCode进行缓存，更加高效。

由于字符串是应用最广泛的数据结构，因此字符串的性能对整个应用程序的总体性能有相当大的影响。

我们可以得出这样的结论：字符串是不可变的，因此它的引用可以被视为普通变量，可以在方法之间和线程之间传递它，而不必担心它所指向的实际字符串对象是否会改变。



#### 8.2 JDK6和JDK7中substring的原理与区别

String是Java中一个比较基础的类，也是面试中经常会考的知识点。substring是String中一个比较常用的方法，而且围绕substring也有很多面试题。

substring(int beginIndex, int endIndex)方法在不同版本的JDK中的实现是不同的。了解它们的区别可以帮助我们更好地使用它们。简单起见，下面用substring()代表substring(int beginIndex, int endIndex)方法。

##### 8.2.1 substring()的作用
substring(int beginIndex, int endIndex)方法用于截取字符串并返回其[beginIndex,endIndex - 1]范围内的内容：

```java
String x = "abcdef";
x = x.substring(1,3);
System.out.println(x);
```

输出内容如下：

bc

##### 8.2.2 调用substring()时发生了什么

因为x是不可变的，当使用x.substring(1,3)对x赋值时，它会指向一个全新的字符串。

![image](https://github.com/user-attachments/assets/705d57ba-ec39-418e-a9ea-662c19181c00)

图8-3没有完全正确地表示堆中发生的事情。因为在JDK6和JDK7中调用substring时发生的事情并不一样。
1. **JDK 6中的substring方法**
String是通过字符数组实现的。在JDK6中，String类包含三个成员变量：char value[]、int offset和int count。它们分别用来存储真正的字符数组、数组的第一个位置索引和字符串包含的字符个数。
当调用substring方法时，会创建一个新的String对象，但这个String的值仍然指向堆中的同一个字符数组，这两个对象中只有count和offset的值是不同的。
下面是证明上述观点的Java源码中的关键代码：

![image](https://github.com/user-attachments/assets/96c0d3e1-c5a5-4ac2-afb1-68656cf252b1)



```java
// JDK 6
String(int offset, int count, char value[]) {
    this.value = value;
    this.offset = offset;
    this.count = count;
}
public String substring(int beginIndex, int endIndex) {
    // check boundary
    return new String(offset + beginIndex, endIndex - beginIndex, value);
}
```

2. **JDK 6中的substring方法使用不当导致的问题**

如果使用substring方法切割一段很长的字符串，而你只需要很短的一段，那么可能导致内存泄漏。因为你需要的只是一小段字符序列，但却引用了整个字符串，这就会导致这个非常长的字符串一直被引用，无法被回收，进而导致内存泄漏。

内存泄漏：在计算机科学中，内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

在JDK 6中，一般用以下方式来解决上述问题，基本原理就是生成一个新的字符串并引用它：

```java
x = x.substring(x, y) + "";
```

JDK 6中subString方法的使用不当会导致内存泄漏的问题已经被官方记录在Java Bug Database中。

3. **JDK 7中的substring方法**

上面提到的问题在JDK7中得到了解决。在JDK7中，substring方法会在堆内存中创建一个新的数组。

Java源码中关于这部分内容的主要代码如下：

![image](https://github.com/user-attachments/assets/c1d7a7ab-777b-4344-b253-1af2fd2ca770)


```java
// JDK 7
public String(char value[], int offset, int count) {
    // check boundary
    this.value = Arrays.copyOfRange(value, offset, offset + count);
}
public String substring(int beginIndex, int endIndex) {
    // check boundary
    int subLen = endIndex - beginIndex;
    return new String(value, beginIndex, subLen);
}
```
以上是JDK 7中的subString方法，其使用new String创建了一个新字符串，避免对老字符串的引用，从而解决了内存泄漏的问题。

所以，如果生产环境中使用的JDK版本小于1.7，那么使用String的subString方法时一定要注意避免内存泄漏。

#### 8.3 replace、replaceAll和replaceFirst的区别

replace、replaceAll和replaceFirst是Java中常用的替换字符的方法，它们的方法的定义如下：

- replace(CharSequence target, CharSequence replacement)：用replacement替换所有的target，两个参数都是字符串。

- replaceAll(String regex, String replacement)：用replacement替换所有的regex匹配项，很明显regex是一个正则表达式，replacement是字符串。 

- replaceFirst(String regex, String replacement)：和replaceAll基本相同，区别是只替换第一个匹配项。


可以看到，replaceAll和replaceFirst是与正则表达式有关的，而replace和正则表达式无关。

replaceAll和replaceFirst的区别主要是替换的内容不同，replaceAll是替换所有匹配的字符，而replaceFirst()仅替换第一次出现的字符。



用法示例：

```java
String string = "abc123adb23456aa";
System.out.println(string);//abc123adb23456aa

// 使用replace将a替换成H
System.out.println(string.replace("a", "H"));//Hbc123Hdb23456HH

// 使用replaceFirst将第一个a替换成H
System.out.println(string.replaceFirst("a", "H"));//Hbc123adb23456aa

// 使用replaceAll将a替换成H
System.out.println(string.replaceAll("a", "H"));//Hbc123Hdb23456HH

// 使用replaceFirst将第一个数字替换成H
System.out.println(string.replaceFirst("\\d", "H"));//abcH23adb23456aa

// 使用replaceAll将所有数字替换成H
System.out.println(string.replaceAll("\\d", "H"));//abcHHHadbHHHHHaa
```

#### 8.4 String对“+”的重载

1. **字符串拼接**

字符串拼接就是把多个字符串拼接到一起。8.1节介绍过String是Java中一个不可变的类，所以它一旦被实例化就无法被修改。既然字符串是不可变的，那么字符串拼接又是怎么回事呢？

其实，所有所谓的字符串拼接，都是重新生成了一个新的字符串。下面是一段字符串拼接的代码：

```java
String s = "abcd";
s = s.concat("ef");
```
最后我们得到的s已经是一个新的字符串了。

s中保存的是一个重新创建出来的String对象的引用。

在Java中，到底如何进行字符串拼接呢？字符串拼接有很多种方式，下面介绍最简单的方式，就是通过“+”拼接两个字符串。

![image](https://github.com/user-attachments/assets/a49671ce-ccaf-4e7c-af3a-99e30c28ad44)


2. **使用“+”拼接字符串**

有人把Java中使用“+”拼接字符串的功能理解为运算符重载。其实并不是，Java是不支持运算符重载的。“+”其实只是Java提供的一个语法糖。

运算符重载：在计算机程序设计中，运算符重载（Operator Overloading）是多态的一种。运算符重载就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

语法糖：语法糖（Syntactic Sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

关于语法糖的更多知识，将在第20章中展开介绍。



如下一段代码：

```java
String wechat = "Hollis";
String introduce = "每日更新Java相关技术文章";
String hollis = wechat + "," + introduce;
```
反编译后的内容如下，反编译工具为jad：
```java
String wechat = "Hollis";
String introduce = "\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0";
```

### 8.5 字符串拼接的几种方式和区别

8.4节介绍了使用“+”进行字符串的拼接，那么是否还有其他方式呢？它们之间有什么区别呢？又该如何选择呢？

如果想知道一共有多少种方式可以进行字符串拼接，那么有一个简单的办法，在IntelliJ IDEA中定义一个JavaBean，然后尝试使用快捷键自动生成一个toString方法，IntelliJ IDEA会提示多种toString生成策略可供选择。

![image](https://github.com/user-attachments/assets/8558a53b-0d0c-4d10-83c5-5cb3d04df7db)


本节基于JDK1.8.0_181进行分析，接下来看一下几种字符串拼接的方式及实现原理。

#### 8.5.1 concat方法是如何实现字符串拼接的

查看concat方法的源代码，看一下concat方法是如何拼接字符串的：

```java
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}
```

这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，然后使用这个字符数组创建一个新的String对象并返回。

通过源码可以看到，concat方法拼接字符串的原理其实是“new”了一个新的String，这也与字符串的不变性相呼应。
#### 8.5.2 StringBuffer和StringBuilder

因为String是一个不可变类，对它的修改会生成新的对象，因此这个过程无疑是有一定成本的，当我们想要创建一个可以改变的字符串时，可以使用JDK中的StringBuffer和StringBuilder两个类，StringBuffer和StringBuilder的对象可以被多次修改，并且不用产生新的对象。

StringBuffer和StringBuilder之间的区别是，StringBuilder的方法并不是线程安全的。

接下来看一下StringBuffer和StringBuilder的实现原理。

和String类类似，StringBuilder类也封装了一个字符数组，定义如下：

```java
char[] value;
```

与String类不同的是，它并不是final的，所以是可以修改的。另外，与String不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：
```java
int count;
```

其append源码如下：

```java
public StringBuilder append(String str) {
    super.append(str);
    return this;
}
```
该类继承了AbstractStringBuilder类，其append方法如下：
```java
public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
```

append方法会直接复制字符到内部的字符数组中，如果字符数组的长度不够，则会进行扩展。

StringBuffer的append方法如下：
```java
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

该方法使用synchronized进行声明，说明是一个线程安全的方法。

#### 8.5.3 StringUtils.join是如何实现字符串拼接的

除了JDK内置的一些方法，我们还可以借助工具类完成字符串的拼接，其中比较常用的是Apache的StringUtils工具类，这个类提供了join方法可以拼接字符串（更多的工具类将在第22章中展开介绍）。

查看StringUtils.join的源代码，我们可以发现，它也是通过StringBuilder实现字符串拼接的：

```java
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0: Len = NoOfStrings *(len(firstString) + len(separator))
    // (Assuming that all Strings are roughly equally long)
    final int noOfItems = endIndex - startIndex;
    if (noOfItems <= 0) {
        return EMPTY;
    }
    final StringBuilder buf = new StringBuilder(noOfItems * 16);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}
```

#### 8.5.4 效率比较

前面介绍了多种字符串拼接的方式，这么多字符串拼接的方式，到底哪一种的效率最高呢？我们需要测试一下，编写如下代码：

```java
long t1 = System.currentTimeMillis();
String str = "Hollis";// 这里是初始字符串定义
for (int i = 0; i < 50000; i++) {
    String s = String.valueOf(i);
    str += s;
    // 这里是字符串拼接代码，可替换成其他的拼接方式
}
long t2 = System.currentTimeMillis();
System.out.println("cost:" + (t2 - t1));
```

我们使用以上形式的代码，分别测试五种字符串拼接代码方式的运行时间，得到的结果如下：
- + cost:5119
- StringBuilder cost:3
- StringBuffer cost:4
- concat cost:3623
- StringUtils.join cost:25726


从结果可以看出，用时从短到长的排序如下：

StringBuilder < StringBuffer < concat < + < StringUtils.join

StringBuffer在StringBuilder的基础上做了同步处理，所以在耗时上会相对多一些。

StringUtils.join也使用了StringBuilder，并且其中还有很多其他操作，所以耗时较长。其实StringUtils.join更擅长处理字符串数组或者列表的拼接。

前面我们分析过，使用“+”拼接字符串的实现原理也是使用的StringBuilder，那么为什么结果相差这么多，高达1000多倍呢？

我们再把以下代码进行反编译：

```java
long t1 = System.currentTimeMillis();
String str = "hollis";
for (int i = 0; i < 50000; i++) {
    String s = String.valueOf(i);
    str += s;
}
long t2 = System.currentTimeMillis();
System.out.println("+ cost:" + (t2 - t1));
```
反编译后的代码如下：
```java
long t1 = System.currentTimeMillis();
String str = "hollis";
for(int i = 0; i < 50000; i++)
{
    String s = String.valueOf(i);
    str = (new StringBuilder()).append(str).append(s).toString();
}
long t2 = System.currentTimeMillis();
System.out.println((new StringBuilder()).append("+ cost:").append(t2 - t1).toString());
```

可以看到，在反编译后的代码的for循环中，每次都“new”了一个StringBuilder，然后把String转成StringBuilder再执行append方法。

而频繁新建对象不仅会耗费很多时间，还会造成内存资源的浪费。

所以，《阿里巴巴Java开发手册》中建议：在循环体内，字符串的连接方式使用StringBuilder的append方法进行扩展，而不要使用“+”。
### 小结

本节介绍了什么是字符串拼接，虽然字符串是不可变的，但还是可以通过新建字符串的方式来进行字符串的拼接。

常用的字符串拼接方式有五种，分别是“+”、concat、StringBuilder、StringBuffer和StringUtils.join。

由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。

因此，经过对比，我们发现，直接使用StringBuilder的方式是效率最高的。因为StringBuilder天生就是设计用来定义可变字符串和字符串的变化操作的。

另外，还要强调的是：

（1）如果不是在循环体中进行字符串拼接，则直接使用“+”。

（2）如果在并发场景中进行字符串拼接，则要使用StringBuffer代替StringBuilder。

### 8.6 StringJoiner

在8.5节中，我们介绍了几种Java中字符串拼接的方式，还有一个重要的拼接方式没有介绍，那就是Java 8中提供的StringJoiner，本节介绍这个字符串拼接的“新兵”。

目前笔者的IDEA的toString生成策略默认使用JDK 1.8提供的StringJoiner。

#### 1. 简介

StringJoiner是java.util包中的一个类，用于构造一个由分隔符分隔的字符序列（可选），可以从参数中提供的前缀开始并以参数提供的后缀结尾。虽然也可以在StringBuilder类的帮助下在每个字符串之后附加分隔符，但StringJoiner提供了简单的方法来实现这个功能，无须编写大量代码。

StringJoiner类共有2个构造函数和5个公有方法，其中最常用的方法就是add方法和toString方法，类似于StringBuilder中的append方法和toString方法。

#### 2. 用法

StringJoiner的用法比较简单，在下面的代码中，我们使用StringJoiner拼接字符串：

```java
public class StringJoinerTest {
    public static void main(String[] args) {
        StringJoiner sj = new StringJoiner("Hollis");
        sj.add("hollischuang");
        sj.add("Java干货");
        System.out.println(sj.toString());
        StringJoiner sj1 = new StringJoiner(":", "[", "]");
        sj1.add("Hollis").add("hollischuang").add("Java干货");
        System.out.println(sj1.toString());
    }
}
```

以上代码的输出结果如下：
- hollischuangHollisJava干货
- [Hollis:hollischuang:Java干货]


值得注意的是，当我们使用StringJoiner(CharSequence delimiter)初始化一个StringJoiner时，这个delimiter其实是分隔符，并不是可变字符串的初始值。

StringJoiner(CharSequence delimiter,CharSequence prefix,CharSequence suffix)的第二个和第三个参数分别是拼接后的字符串的前缀和后缀。
#### 3. 原理

介绍了简单的用法之后，我们再来看一下StringJoiner的原理，看一下它到底是如何实现的，主要看一下add方法：

```java
public StringJoiner add(CharSequence newElement) {
    prepareBuilder().append(newElement);
    return this;
}
private StringBuilder prepareBuilder() {
    if (value != null) {
        value.append(delimiter);
    } else {
        value = new StringBuilder().append(prefix);
    }
    return value;
}
```

我们看到了一个熟悉的身影——StringBuilder，StringJoiner其实就是依赖StringBuilder实现的。

当我们发现StringJoiner其实是通过StringBuilder实现的之后，大概就可以猜到，它的性能损耗应该和直接使用StringBuilder差不多。

#### 4. 为什么需要StringJoiner

了解StringJoiner的用法和原理之后，可能很多读者会产生一个疑问：明明已经有一个StringBuilder了，为什么Java 8中还要定义一个StringJoiner呢？到底有什么好处呢？

如果读者足够了解Java 8，或许可以猜出个大概，这肯定和Stream有关。

笔者也在Java Doc中找到了答案：

A StringJoiner may be employed to create formatted output from a Stream using Collectors.joining(CharSequence)

在Java中，如果我们有如下一个List：

```java
List<String> list = ImmutableList.of("Hollis","hollischuang","Java干货");
```

我们想要把它拼接成以下形式的一个字符串：

Hollis,hollischuang,Java干货

则可以通过以下方式实现：

```java
StringBuilder builder = new StringBuilder();
if (!list.isEmpty()) {
    builder.append(list.get(0));
    for (int i = 1, n = list.size(); i < n; i++) {
        builder.append(",").append(list.get(i));
    }
}
builder.toString();
```

还可以使用：

```java
list.stream().reduce(new StringBuilder(), (sb, s) -> sb.append(s).append(','), StringBuilder::append).toString();
```

但是输出结果稍有不同，需要进行二次处理：

Hollis,hollischuang,Java干货,

还可以使用“+”进行拼接：

```java
list.stream().reduce((a,b)->a + "," + b).toString();
```

以上几种方式，要么代码复杂，要么性能不高，或者无法直接得到想要的结果。

为了满足类似这样的需求，Java 8中提供的StringJoiner就派上用场了。以上需求只需要一行代码就可以实现：

```java
list.stream().collect(Collectors.joining(":"))
```

上面的表达式中Collectors.joining的源代码如下：

```java
public static Collector<CharSequence, ?, String> joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix) {
    return new CollectorImpl<>(
        () -> new StringJoiner(delimiter, prefix, suffix),
        StringJoiner::add, StringJoiner::merge,
        StringJoiner::toString, CH_NOID);
}
```

其实现原理就是借助了StringJoiner。

当然，在Collector中直接使用StringBuilder也可以实现类似的功能，只不过稍微麻烦一些。所以，Java 8中提供了StringJoiner来丰富Stream的用法。

而且StringJoiner也可以方便地增加前缀和后缀，比如我们希望得到的字符串是[Hollis,hollischuang,Java干货]而不是Hollis,hollischuang,Java干货，那么StringJoiner的优势就更加明显了。

### 小结

本节介绍了Java 8中提供的可变字符串类——StringJoiner，其可以用于字符串拼接。

StringJoiner是通过StringBuilder实现的，所以它的性能和StringBuilder差不多，StringJoiner也是非线程安全的。

如果在日常开发中需要进行字符串拼接，那么该选择哪种方式呢？

（1）如果是简单的字符串拼接，则直接使用“+”。

（2）如果是在for循环中进行字符串拼接，则使用StringBuilder和StringBuffer。 

(3) 如果是通过一个List进行字符串的拼接，则使用StringJoiner


### 8.7 从字符串中删除空格的多种方式

我们在日常开发中经常使用字符串做很多操作，比如字符串的拼接、截断、替换等。本节介绍一个比较常见又容易被忽略的操作，即删除字符串中的空格。

其实，从字符串中删除空格有很多不同的方法，如trim()、replaceAll()等。在Java 11中添加了一些新的功能，如strip()、stripLeading()、stripTrailing()等。

大多数时候，我们只是使用trim方法来删除多余的空格，很多人并没有思考过是否有更好的方式。

当然，trim()方法在大多数情况下都工作得很好，但是Java中有许多不同的方法，每一种方法都有自己的优点和缺点，我们如何分辨哪种方法最适合呢？

接下来将介绍几种方法，并对比它们的区别和优缺点等。

首先，我们来看一下想要从字符串中删除空格部分有多少种方法，笔者根据经验，总结了以下7种（JDK原生自带的方法，不包含第三方工具库中的类似方法）：

- trim()：删除字符串开头和结尾的空格。

- strip()：删除字符串开头和结尾的空格。

- stripLeading()：只删除字符串开头的空格。

- stripTrailing()：只删除字符串结尾的空格。

- replace()：用新字符替换所有目标字符。

- replaceAll()：将所有匹配的字符替换为新字符。此方法将正则表达式作为输入，以标识需要替换的目标子字符串。

- replaceFirst()：仅将目标子字符串中第一次出现的字符替换为新的字符串。



需要注意的是，在Java中String对象是不可变的，这意味着我们不能修改字符串，因此以上所有的方法得到的都是一个新的字符串。

接下来，我们分别学习以上这几个方法的用法，了解其特性。

#### 1. trim()

trim()是Java开发人员常用的删除字符串开头和结尾的空格的方法，其用法也比较简单：

```java
public class StringTest {
    public static void main(String[] args) {
        String stringWithSpace = "  Hollis  Is  A  Java  Coder  ";
        StringTest.trimTest(stringWithSpace);
    }
    private static void trimTest(String stringWithSpace){
        System.out.println("Before trim : \'" + stringWithSpace + "\'");
        String stringAfterTrim = stringWithSpace.trim();
        System.out.println("After trim : \'" + stringAfterTrim + "\'");
    }
}
```

输出结果如下：


- Before trim : '  Hollis  Is  A  Java  Coder  '

- After trim : 'Hollis  Is  A  Java  Coder'



使用trim()方法之后，原字符串中开头和结尾部分的空白内容都被删除了。

不知道读者有没有思考过，trim()方法删除的空白内容都包含什么？除了空格，还有其他的字符吗？

其实，trim()方法删除的空白字符指的是ASCII值小于或等于32的任何字符（U+0020），其中包含空格、换行、退格等字符。

#### 2. strip()

在Java 11的发行版中，添加了新的strip()方法来删除字符串中的前导和末尾空格。

已经有了一个trim()方法，为什么还要新增一个strip()方法呢？

这是因为trim()方法只能删除ASCII值小于等于32的字符，但根据Unicode标准，除了ASCII中的字符，还有很多其他的空白字符。

为了识别这些空格字符，从Java 1.5开始，在Character类中添加了新的isWhitespace(int)方法，该方法使用Unicode来标识空格字符。

```java
/**
 * Determines if the specified character (Unicode code point) is
 * white space according to Java. A character is a Java
 * whitespace character if and only if it satisfies one of the
 * following criteria:
 * <ul>
 * <li>It is a Unicode space character ({@link #SPACE_SEPARATOR},
 * {@link #LINE_SEPARATOR}, or {@link #PARAGRAPH_SEPARATOR})
 * but is not also a non - breaking space ({@code '\u00A0'},
 * {@code '\u2007'}, {@code '\u202F'}).
 * <li>It is {@code '\u0009'}, HORIZONTAL TABULATION.
 * <li>It is {@code '\u000A'}, LINE FEED.
 * <li>It is {@code '\u000B'}, VERTICAL TABULATION.
 * <li>It is {@code '\u000C'}, FORM FEED.
 * <li>It is {@code '\u000D'}, CARRIAGE RETURN.
 * <li>It is {@code '\u001C'}, FILE SEPARATOR.
 * <li>It is {@code '\u001D'}, GROUP SEPARATOR.
 * <li>It is {@code '\u001E'}, RECORD SEPARATOR.
 * <li>It is {@code '\u001F'}, UNIT SEPARATOR.
 * </ul>
 * <p>
 * @param  codePoint the character (Unicode code point) to be tested.
 * @return {@code true} if the character is a Java whitespace
 * character; {@code false} otherwise.
 * @see    Character#isSpaceChar(int)
 * @since  1.5
 */
public static boolean isWhitespace(int codePoint) {
    return CharacterData.of(codePoint).isWhitespace(codePoint);
}
```
而在Java 11中新增的strip()方法就是使用Character.isWhitespace(int)方法来判断字符是否为空白字符并删除它们的：
```java
public static String strip(byte[] value) {
    int left = indexOfNonWhitespace(value);
    if (left == value.length) {
        return "";
    }
    int right = lastIndexOfNonWhitespace(value);
    boolean ifChanged = (left > 0) || (right < value.length);
    return ifChanged ? newString(value, left, right - left) : null;
}
public static int indexOfNonWhitespace(byte[] value) {
    int length = value.length;
    int left = 0;
    while (left < length) {
        char ch = getChar(value, left);
        if (ch != ' ' && ch != '\t' &&!Character.isWhitespace(ch)) {
            break;
        }
        left++;
    }
    return left;
}
```
下面我们来看一个使用strip()方法例子：
```java
public class StringTest {
    public static void main(String args[]) {
        String stringWithSpace = '\u2001' + "  Hollis  Is  A  Java  Coder  " + '\u2001';
        System.out.println("'" + '\u2001' + "' is space : " + Character.isWhitespace('\u2001'));
        StringTest.stripTest(stringWithSpace);
    }
    private static void stripTest(String stringWithSpace){
        System.out.println("Before strip : \'" + stringWithSpace + "\'");
        String stringAfterTrim = stringWithSpace.strip();
        System.out.println("After strip : \'" + stringAfterTrim + "\'");
    }
}
```
我们在字符串前后都增加了一个特殊的字符“\u2001”，这个字符是不在ASCII中的，经过Character.isWhitespace方法判断，它是一个空白字符。然后使用strip()方法进行处理，输出结果如下：
- ' ' is space : true
- Before strip : '  Hollis  Is  A  Java  Coder  '
- After strip : 'Hollis  Is  A  Java  Coder'


所以，Java 11中的strip()方法要比trim()方法更加强大，它可以删除很多不在ASCII中的空白字符，具体方式就是使用Character.isWhitespace方法进行判断。

trim()方法和strip()方法的区别如下表所示：

| trim() | strip() |
| --- | --- |
| Java 1引入 | Java 11引入 |
| 使用Unicode值，删除开头和结尾的空白字符 | 删除开头和结尾的空白字符 |
| 删除ASCII值小于/等于U+0020或32的字符 | 根据Unicode删除所有空格字符 |

#### 3. stripLeading()和stripTrailing()

stripLeading()和stripTrailing()方法也都是在Java 11中添加的，作用分别是删除字符串的开头的空格，以及删除字符串的末尾的空格。

与strip()方法类似，stripLeading、stripTrailing也使用Character.isWhitespace(int)来标识空白字符，用法也和strip()方法类似：

```java
public class StringTest {
    public static void main(String args[]) {
        String stringWithSpace = '\u2001' + "  Hollis  Is  A  Java  Coder  " + '\u2001';
        System.out.println("'" + '\u2001' + "' is space : " + Character.isWhitespace('\u2001'));
        StringTest.stripLeadingTest(stringWithSpace);
        StringTest.stripTrailingTest(stringWithSpace);
    }
    private static void stripLeadingTest(String stringWithSpace){
        System.out.println("Before stripLeading : \'" + stringWithSpace + "\'");
        String stringAfterTrim = stringWithSpace.stripLeading();
        System.out.println("After stripLeading : \'" + stringAfterTrim + "\'");
    }
    private static void stripTrailingTest(String stringWithSpace){
        System.out.println("Before stripTrailing : \'" + stringWithSpace + "\'");
        String stringAfterTrim = stringWithSpace.stripTrailing();
        System.out.println("After stripTrailing : \'" + stringAfterTrim + "\'");
    }
}
```
输出结果如下：
- ' ' is space : true
- Before stripLeading : '  Hollis  Is  A  Java  Coder  '
- After stripLeading : 'Hollis  Is  A  Java  Coder  '
- Before stripTrailing : '  Hollis  Is  A  Java  Coder  '
- After stripTrailing : '  Hollis  Is  A  Java  Coder'
#### 4. replace()

除了使用trim()方法、strip()方法移除字符串中的空白字符，还有一个办法，那就是使用replace()方法替换其中的空白字符。

replace()是从Java 1.5开始添加的方法，可以用指定的字符串替换每个目标子字符串。

此方法替换所有匹配的目标元素，使用方式如下：
```java
public class StringTest {
    public static void main(String args[]) {
        String stringWithSpace = "  Hollis  Is  A  Java  Coder  ";
        StringTest.replaceTest(stringWithSpace);
    }
    private static void replaceTest(String stringWithSpace){
        System.out.println("Before replace : \'" + stringWithSpace + "\'");
        String stringAfterTrim = stringWithSpace.replace(" ", "");
        System.out.println("After replace : \'" + stringAfterTrim + "\'");
    }
}
```

结果如下：

- Before replace : '  Hollis  Is  A  Java  Coder  '

- After replace : 'HollisIsAJavaCoder'


可见，使用replace()方法可以替换字符串中的所有空白字符。需要特别注意的是，replace()方法和trim()方法一样，只能替换ASCII中的空白字符。

#### 5. replaceAll()

replaceAll()是Java 1.4中添加的最强大的字符串操作方法之一，我们可以使用这种方法达到许多目的。

我们可以使用replaceAll()和正则表达式来识别需要被替换的目标字符。使用正则表达式可以实现很多功能，如删除所有空格、删除开头空格、删除结尾空格等。

我们只需要使用正确的替换参数创建正确的正则表达式即可。一些正则表达式的例子如下：

- \\s+：所有的空白字符。

- ^\\s+：字符串开头的所有空白字符。

- \\s+$：字符串结尾的所有空白字符。



注意，在Java中要添加“/”，我们必须使用转义字符，所以对于“s+”，我们必须使用“\\s+”：

```java
public class StringTest {
    public static void main(String args[]) {
        String stringWithSpace = "  Hollis  Is  A  Java  Coder  ";
        StringTest.replaceAllTest(stringWithSpace," ");
        StringTest.replaceAllTest(stringWithSpace,"\\s+");
        StringTest.replaceAllTest(stringWithSpace,"^\\s+");
        StringTest.replaceAllTest(stringWithSpace,"\\s+$");
    }
    private static void replaceAllTest(String stringWithSpace,String regex){
        System.out.println("Before replaceAll with '"+ regex +"': \'"+ stringWithSpace +"\'");
        String stringAfterTrim = stringWithSpace.replaceAll(regex, "");
        System.out.println("After replaceAll with '"+ regex +"': \'"+ stringAfterTrim +"\'");
    }
}
```
结果如下：
- Before replaceAll with ' ': '  Hollis  Is  A  Java  Coder  '
- After replaceAll with ' ': 'HollisIsAJavaCoder'
- Before replaceAll with '\\s+': '  Hollis  Is  A  Java  Coder  '
- After replaceAll with '\\s+': 'HollisIsAJavaCoder'
- Before replaceAll with '^\\s+': '  Hollis  Is  A  Java  Coder  '
- After replaceAll with '^\\s+': 'Hollis  Is  A  Java  Coder  '
- Before replaceAll with '\\s+$': '  Hollis  Is  A  Java  Coder  '
- After replaceAll with '\\s+$': '  Hollis  Is  A  Java  Coder'


正如我们所看到的，如果将replaceAll()与适当的正则表达式一起使用，那么它将是非常强大的方法。

#### 6. replaceFirst()

replaceFirst()也是在Java 1.4中添加的方法，它只将给定正则表达式的第一个匹配项替换为替换字符串。

如果只需要替换第一次出现的字符串，那么这个方法非常有用。例如，如果只需要删除前导空格，则可以使用“\\s+”或“^\\s+”。

我们还可以通过使用“\\s+$”来删除末尾空格。因为这个表达式只匹配行的最后一个空格。因此最后的空格被认为是这个方法的第一个匹配项。

举一个从字符串中删除前导和尾随空格的例子：

```java
public class StringTest {
    public static void main(String args[]) {
        String stringWithSpace = "  Hollis  Is  A  Java  Coder  ";
        StringTest.replaceFirstTest(stringWithSpace," ");
        StringTest.replaceFirstTest(stringWithSpace,"\\s+");
        StringTest.replaceFirstTest(stringWithSpace,"^\\s+");
        StringTest.replaceFirstTest(stringWithSpace,"\\s+$");
    }
    private static void replaceFirstTest(String stringWithSpace,String regex){
        System.out.println("Before replaceFirst with '"+ regex +"': \'"+ stringWithSpace +"\'");
        String stringAfterTrim = stringWithSpace.replaceFirst(regex, "");
        System.out.println("After replaceFirst with '"+ regex +"': \'"+ stringAfterTrim +"\'");
    }
}
```
结果如下：
- Before replaceFirst with ' ': '  Hollis  Is  A  Java  Coder  '
- After replaceFirst with ' ': 'Hollis  Is  A  Java  Coder  '
- Before replaceFirst with '\\s+': '  Hollis  Is  A  Java  Coder  '
- After replaceFirst with '\\s+': 'Hollis  Is  A  Java  Coder  '
- Before replaceFirst with '^\\s+': '  Hollis  Is  A  Java  Coder  '
- After replaceFirst with '^\\s+': 'Hollis  Is  A  Java  Coder  '
- Before replaceFirst with '\\s+$': '  Hollis  Is  A  Java  Coder  '
- After replaceFirst with '\\s+$': '  Hollis  Is  A  Java  Coder'
### 小结
本节介绍了7种删除字符串中的空白字符的方法。
- 想要直接删除字符串开头的空白字符，可以使用stripLeading()、replaceAll()和replaceFirst()。
- 想要直接删除字符串末尾的空白字符，可以使用stripTrailing()、replaceAll()和replaceFirst()。
- 想要同时删除字符串开头和结尾的空白字符，可以使用strip()和trim()。
- 想要删除字符串中的所有空白字符，可以使用replace()和replaceAll()。

Java 11中新增的strip()、stripTrailing()和stripLeading()方法可以删除的字符要比其他方法多，它们可以删除的空白字符不仅仅局限于ASCII中的字符，而是Unicode中的所有空白字符，具体可以使用Character.isWhitespace方法进行判断。

### 8.8 switch对String的支持

在Java 7中，switch的参数可以是String类型，这对我们来说是一个很方便的改进。但是，作为一个程序员，我们不仅要知道它有多么好用，还要知道它是如何实现的。switch对整型的支持是怎么实现的呢？对字符的支持是怎么实现的呢？对字符串的支持是怎么实现的呢？

有Java开发经验的人会猜测switch对String的支持是基于equals()方法和hashCode()方法。那么到底是不是这两个方法呢？

#### 1. switch对整型的支持

下面是一段简单的Java代码，定义了一个int型变量a，然后使用switch语句进行判断


### 8.8 switch对String的支持

在Java 7中，switch的参数可以是String类型，这是一个很方便的改进。作为程序员，我们需要了解它的实现原理。很多人猜测switch对String的支持基于equals()方法和hashCode()方法，下面我们来探究一下。

#### 1. switch对整型的支持

先看一段简单代码：
```java
public class switchDemoInt {
    public static void main(String[] args) {
        int a = 5;
        switch (a) {
            case 1:
                System.out.println(1);
                break;
            case 5:
                System.out.println(5);
                break;
            default:
                break;
        }
    }
}
```
反编译后的代码如下：
```java
public class switchDemoInt {
    public switchDemoInt() {}
    public static void main(String args[]) {
        int a = 5;
        switch(a) {
            case 1: // '\001'
                System.out.println(1);
                break;
            case 5: // '\005'
                System.out.println(5);
                break;
        }
    }
}
```
反编译后的代码和原代码相比，除了多两行注释无其他区别，可知switch对int型变量的判断是直接比较整数值。

#### 2. switch对字符的支持

代码示例：

```java
public class switchDemoInt {
    public static void main(String[] args) {
        char a = 'b';
        switch (a) {
            case 'a':
                System.out.println('a');
                break;
            case 'b':
                System.out.println('b');
                break;
            default:
                break;
        }
    }
}
```

编译后的代码：

```java
public class switchDemoChar {
    public switchDemoChar() {}
    public static void main(String args[]) {
        char a = 'b';
        switch(a) {
            case 97: // 'a'
                System.out.println('a');
                break;
            case 98: // 'b'
                System.out.println('b');
                break;
        }
    }
}
```

比较编译前后代码可知，比较char型变量时，实际比较的是ASCII码，编译器会把char型变量转换成对应的int型变量。

#### 3. switch对字符串的支持

代码示例：

```java
public class switchDemoString {
    public static void main(String[] args) {
        String str = "world";
        switch (str) {
            case "hello":
                System.out.println("hello");
                break;
            case "world":
                System.out.println("world");
                break;
            default:
                break;
        }
    }
}
```

反编译后的代码：

```java
public class switchDemoString {
    public switchDemoString() {}
    public static void main(String args[]) {
        String str = "world";
        String s;
        switch((s = str).hashCode()) {
            default:
                break;
            case 99162322:
                if(s.equals("hello"))
                    System.out.println("hello");
                break;
            case 113318802:
                if(s.equals("world"))
                    System.out.println("world");
                break;
        }
    }
}
```

可以看出，字符串的switch是通过equals()和hashCode()方法实现的。switch只支持整型（byte、short、char、int ），hashCode()方法返回int类型。进行switch操作实际是比较Hash值，然后用equals方法进行安全检查 ，因为Hash可能碰撞。如果是字符串字面量比较，性能不会很差，因为Java编译器对字符串会缓存Hash值。若switch在循环里，hashCode()方法调用开销影响不大。


在JDK17中，提供了switch模式匹配新功能，进一步增强了switch功能，相关内容将在23.12节展开介绍。

### 8.9 字符串池

字符串是常用类，为减少相同字符串重复创建占用过多内存，《Java虚拟机规范》规定：相同的字符串常量必须指向同一个String实例。存储这些String实例的地方叫字符串池（String Pool ，也叫String Constant Pool、String Table等 ）。

#### 1. 字符串池的实现方式

不同虚拟机及版本中，字符串池实现方式不同。在HotSpot虚拟机中，定义stringTable保存字符串引用。不同版本HotSpot虚拟机中，字符串池位置不同：JDK 1.6及之前版本，字符串池位于永久代；因永久代实现方法区可能导致内存泄漏，从JDK1.7开始，字符串池转移到堆内存中。

#### 2. 池中常量的来源

运行时常量池常量来源主要有两种：

- 编译器可知的字面量和符号引用。

- 运行期解析后可获得的常量。




### 8.10 Class常量池

Java编译过程是把Java文件编译成Class文件，Class常量池可理解为Class文件中的资源仓库，除包含类的版本、字段、方法、接口等描述信息，还包含常量池（Constant Pool Table ），用于存放编译器生成的各种字面量（Literal）和符号引用（Symbolic References ）。因不同Class文件常量个数不固定，在Class文件的常量池入口处会设置两个字节的常量池容量计数器记录常量个数。

![image](https://github.com/user-attachments/assets/f1e050e6-5936-4710-9d45-81b354b0e2f6)


可通过javap命令查看Class文件常量池内容。以HelloWorld类为例：

```java

public class HelloWorld {
    public static void main(String[] args) {
        String s = "Hollis";
    }
}
```

通过`javac HelloWorld.java`生成HelloWorld.class文件，再通过`javap -v HelloWorld.class`查看常量池：

```
public class com.hollis.HelloWorld
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#13         // java/lang/Object."<init>":()V
   #2 = String             #14            //  Hollis
   #3 = Class              #15            //  com/hollis/HelloWorld
   #4 = Class              #16            //  java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               main
  #10 = Utf8               ([Ljava/lang/String;)V
  #11 = Utf8               SourceFile
  #12 = Utf8               HelloWorld.java
  #13 = NameAndType        #5:#6          //  "<init>":()V
  #14 = Utf8               Hollis
  #15 = Utf8               com/hollis/HelloWorld
  #16 = Utf8               java/lang/Object
{
  public com.hollis.HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: ldc           #2                  // String Hollis
         2: astore_1
         3: return
      LineNumberTable:
        line 5: 0
        line 6: 3
}
SourceFile: "HelloWorld.java"
```

反编译后的Class文件常量池共有16个常量，主要分为字面量和符号引用两大类。

#### 1. 字面量

字面量是用于表达源代码中一个固定值的表示法 ，几乎所有计算机编程语言都有基本值的字面量表示，如整数、浮点数、字符串 ，甚至枚举类型元素、数组、记录和对象等复合类型的值也支持字面量表示。简单说，字面量是指由字母、数字等构成的字符串或者数值，只能以右值出现 ，如`int a = 123;`中，123是字面量；`String s = "hollis";`中，hollis是字面量。



以以下代码为例：
```java
public static void main(String[] args) {
    String s1 = "Hollis";
    String s2 = "Hollis" + "Chuang";
    String s3 = new String("Hol") + new String("lis666");
    String s4 = new StringBuilder("Holl").append("is888").toString();
}
```
通过`javac StringPool.java`和`javap -v StringPool`查看常量池：
```
Constant pool:
   #1 = Methodref          #16.#25        // java/lang/Object."<init>":()V
   #2 = String             #26            //  Hollis
   #3 = String             #27            //  HollisChuang
   #4 = Class              #28            //  java/lang/StringBuilder
   #5 = Methodref          #4.#25         //  java/lang/StringBuilder."<init>":()V
   #6 = Class              #29            //  java/lang/String
   #7 = String             #30            //  Hol
   #8 = Methodref          #6.#31         //  java/lang/String."<init>":(Ljava/lang/String;)V
   #9 = Methodref          #4.#32         //  java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
  #10 = String             #33            //  lis666
  #11 = Methodref          #4.#34         //  java/lang/StringBuilder.toString:()Ljava/lang/String;
  #12 = String             #35            //  Holl
  #13 = Methodref          #4.#31         //  java/lang/StringBuilder."<init>":(Ljava/lang/String;)V
  #14 = String             #36            //  is888
  #15 = Class              #37            //  com/hollis/HelloWorld
  #16 = Class              #38            //  java/lang/Object
  #17 = Utf8               <init>
  #18 = Utf8               ()V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               main
  #22 = Utf8               ([Ljava/lang/String;)V
  #23 = Utf8               SourceFile
  #24 = Utf8               HelloWorld.java
  #25 = NameAndType        #17:#18        //  "<init>":()V
  #26 = Utf8               Hollis
  #27 = Utf8               HollisChuang
  #28 = Utf8               java/lang/StringBuilder
  #29 = Utf8               java/lang/String
  #30 = Utf8               Hol
  #31 = NameAndType        #17:#39        //  "<init>":(Ljava/lang/String;)V
  #32 = NameAndType        #40:#41        //  append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
  #33 = Utf8               lis666
  #34 = NameAndType        #42:#43        //  toString:()Ljava/lang/String;
  #35 = Utf8               Holl
  #36 = Utf8               is888
  #37 = Utf8               com/hollis/HelloWorld
  #38 = Utf8               java/lang/Object
  #39 = Utf8               (Ljava/lang/String;)V
  #40 = Utf8               append
  #41 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
  #42 = Utf8               toString
  #43 = Utf8               ()Ljava/lang/String;
```

可以看到，Class文件常量池包含Hollis、HollisChuang、Hol、lis666、Holl、is888这6个常量 ，被双引号定义的字符串会作为常量放到常量池。两个双引号形式字符串直接拼接（如 "Hollis" + "Chuang" ）也会放常量池，其他字符串编译期不存在，所以Class常量池中看不到。

#### 2. 符号引用

符号引用是编译原理概念，相对于直接引用，主要包括三类常量：

- 类和接口的全限定名。

- 字段的名称和描述符。

- 方法的名称和描述符。



这解释了常量池中包含`com/hollis/HelloWorld`、`main`、`([Ljava/lang/String;)V`等常量的原因。

#### 3. Class常量池有什么用

Class常量池是Class文件的资源仓库，保存各种开发者定义、运行期需使用的常量。Java代码编译不像C和C++有“连接”步骤，而是虚拟机加载Class文件时进行动态连接。

Class文件不保存方法、字段最终内存布局信息，字段、方法的符号引用需运行期转换才能得到内存入口地址供虚拟机使用。虚拟机运行时，从常量池获取符号引用，

在类创建或运行时解析、翻译到具体内存地址。即Class文件是保存常量的媒介场所和中间场所，JVM运行时将常量池常量加载到运行时常量池，方便运行期使用。

![image](https://github.com/user-attachments/assets/c1f00fdd-dc1e-44c5-9b6a-433c6e87c5c2)


### 8.11 字面量是什么时候存入字符串池的
Java类中定义的字面量编译后存储在Class文件常量池，那Class常量池中的字符串常量何时进入运行期的字符串池呢？是类加载时立即存入吗？ （文档此处未继续阐述，未给出相关结论 ） 


### 8.11 字面量是什么时候存入字符串池的
Java的类加载过程要经历加载（Loading）、链接（Linking）、初始化（Initializing）等几个步骤，在链接这个步骤中，又分为验证（Verification）、准备（Preparation）和解析（Resolution）等几个步骤。

在Java虚拟机规范及Java语言规范中都提到过：
- 《The Java Virtual Machine Specification》5.4 Linking：
  For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used ("lazy" or "late" resolution), or to resolve them all at once when the class is being verified ("eager" or "static" resolution).
- 《The Java Language Specification》12.3 Linking of Classes and Interfaces：
  For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.

大致意思是，Java虚拟机的实现可以选择只有在用到类或者接口中的符号引用时才去逐一解析（延迟解析），或者在验证类时就解析每个引用（预先解析）。这意味着在一些虚拟机的实现中，把常量放到常量池的步骤可能是延迟处理的。

对于HotSpot虚拟机来说，字符串字面量和其他基本类型的常量不同，并不会在类加载的解析阶段填充并驻留在字符串常量池中，而是以特殊的形式存储在运行时常量池中。只有当这个字符串字面量被调用时，才会对其进行解析，开始为它在字符串常量池中创建对应的String实例。

通过查看HotSpot JDK 1.8的ldc指令的源代码，也可以验证上面的说法。ldc指令：把int、float或String型常量从常量池推送至栈顶。
```java
IRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))
  // access constant pool
  ConstantPool* pool = method(thread)->constants();
  int index = wide ? get_index_u2(thread, Bytecodes::_ldc_w) : get_index_u1(thread, Bytecodes::_ldc);
  constantTag tag = pool->tag_at(index);

  assert (tag.is_unresolved_klass() || tag.is_klass(), "wrong ldc call");
  Klass* klass = pool->klass_at(index, CHECK);
  oop java_class = klass->java_mirror();
  thread->set_vm_result(java_class);
IRT_END
```
后面会通过intern的实例来验证本节的结论。

### 8.12 intern
有一种可以在运行期向字符串中动态加入字符串实例的方式，那就是使用intern方法。

intern的功能很简单，总结起来就一句话：可以在运行时向字符串池中添加字符串常量。添加的原则是，如果常量池中存在当前字符串，则直接返回常量池中它的引用；如果常量池中没有此字符串，则将此字符串的引用放入常量池，然后返回这个引用。

前面说过，字符串进入常量池有两个途径，第一是字面量在编译期会进入Class的常量池，在类加载后会进入运行时常量池。第二是使用intern。接下来分情况来看intern的作用及原理，本节的例子都是基于JDK 1.7以后的，因为JDK 1.7之前的常量池所处的位置不同，所以会与本节的例子和结论有差异。

#### 8.12.1 常量池中已存在字符串

前面说过，如果常量池中存在当前字符串，则直接返回常量池中它的引用。下面通过几个示例来验证一下。

- **示例一**：

```java
public static void main(String[] args) {
    String s1 = "Hollis"; // ①
    String s2 = (new String("Hol") + new String("lis")).intern(); // ②
    System.out.println(s2 == s1); // ③ true
}
```

第①行：创建Hollis对象，并将其引用赋值给s1。

第②行：对拼接后的字符串使用intern，因为字符串池中已经存在了"Hollis"字符串，因此会把它的引用返回，并赋值给s2。

所以，s2和s1是相等的。

- **示例二**：

```java
public static void main(String[] args) {
    String s1 = new String("1"); // ①
    s1.intern(); // ②
    String s2 = "1";// ③
    System.out.println(s1 == s2); // ④ false
    String s3 = new String("1") + new String("1");// ⑤
    s3.intern();// ⑥
    String s4 = "11";// ⑦
    System.out.println(s3 == s4); // ⑧ true
}
```

以上代码被编译及加载后，常量池中应该有"1"和"11"两个字符串。

第①行：新建一个String对象，并让s1指向它。

第②行：对s1执行intern，因为"1"已经在字符串中，所以会直接返回原来的引用，但并没有赋值给任何一个变量。

第③行：s2指向常量池中的"1"。

所以，s1和s2并不相等。


如果执行完整段代码就会发现，s1 == s2的结果是false，但s3 == s4的结果是true。很多人看到这里就会产生疑惑，怎么会出现这样的现象呢？

按照之前的理解，这个类被编译及加载后，常量池中应该有"1"和"11"这两个字符串。所以，s3与s4的关系应该和s1与s2的关系一样不相等才对，但为何结果却恰恰相反？


虽然"1"和"11"这两个字面量在Class常量池中都有，但它们真正进入字符串池的时机不一样。因为只有当这个字符串字面量被调用时，才会对其进行解析，开始为它在字符串常量池中创建对应的String实例。

所以，字面量"1"在代码①这一行就会被存入字符串池，而字面量"11"则是在代码⑦这一行才会存入字符串池。

实际情况是这样的：

第⑤行：新建一个String对象，并让s3指向它。

第⑥行：对s3执行intern，但目前字符串池中还没有"11"这个字符串，于是会把这个字符串放入字符串常量池。

第⑦行：因为"11"这个字符串已经在字符串中，所以会直接返回原来的引用，并赋值给s4。

所以，s3和s4相等。



#### 8.12.2 常量池中不存在字符串

前面说过，如果常量池中没有此字符串，则将此字符串的引用放入常量池，然后返回这个引用。下面通过几个示例来验证一下。

- **示例一**：

```java
public static void main(String[] args) {
    String s1 = new String("Hol") + new String("lis"); // ①
    String s2 = s1.intern();// ②
    System.out.println(s1 == s2); // true
}
```
这个类被编译后，Class常量池中应该有"Hol"和"lis"两个字符串，并且这两个字符串在第①句会被存放到运行时字符串池中。

第①行：创建一个"Hollis"对象，没有放入字符串常量池，s1指向这个"Hollis"对象。

第②行：字符串常量池中还没有"Hollis"，于是会把它放入字符串常量池，然后将这个引用（s1的那个引用）返回给了s2。

所以，s1 == s2的结果肯定是true。

- **示例二**：


```java
public static void main(String[] args) {
    String s1 = new String("Hol") + new String("lis");// ①
    s1.intern();// ②
    String s2 = new StringBuilder("Holl").append("is").toString();// ③
    System.out.println(s2 == s1); // ④ false
    System.out.println(s2.intern() == s1); // ⑤ true
}
```
这个类被编译后，Class常量池中应该有"Hol"、"lis"、"Holl"和"is"这4个字符串。

第①行：把"Hol"和"lis"这两个字符串存放到运行时字符串池中，然后创建一个"Hollis"对象，没有放入字符串常量池，s1指向这个"Hollis"对象。

第②行：字符串常量池里面还没有"Hollis"，于是会把它放入字符串常量池。

第③行：把"Holl"和"is"这两个字符串存放到运行时字符串池中，然后创建一个新的"Hollis"对象，s2指向这个"Hollis"对象。

所以，s1和s2并不相等。但s2.intern()会从池中取出已有的引用，这就和s1相等了。


### 8.13 String有没有长度限制

在对String有了一些了解后，可能会有疑问：String有没有长度限制呢？

想要搞清楚这个问题，首先需要翻阅一下String的源码，查看其中是否有关于长度的限制或者定义。

String类中有很多重载的构造函数，其中有几个构造函数是支持用户传入length来指定长度的：

```java
public String(byte bytes[], int offset, int length)
```

可以看到，参数length是使用int类型定义的，也就是说，字符串最大支持的长度就是int的最大范围值吗？


根据Integer类的定义，java.lang.Integer#MAX_VALUE的最大值是2³¹ - 1。

但这并不是String能支持的最大长度，这个值只是在运行期构造String时可支持的一个最大长度，实际上在编译期定义字符串时也是有长度限制的。

例如以下代码：

```java
String s = "11111...1111";// 其中有10万个字符“1”
```

当执行javac编译时会抛出异常，提示信息如下：

错误：常量字符串过长


明明String的构造函数指定的长度是可以支持2147483647（2³¹ - 1）的，为什么像以上形式定义字符串时却无法编译呢？

其实，当按照String s = "xxx"的形式定义字符串时，xxx被称为字面量，这种字面量在编译之后会以常量的形式进入Class常量池。因为要进入常量池，所以就要遵守常量池的有关规定。


#### 8.13.1 常量池限制

javac是将Java文件编译成Class文件的命令，在Class文件生成的过程中，需要遵守一定的格式。

根据《Java虚拟机规范》中4.4节对常量池的定义，CONSTANT_String_info用于表示java.lang.String类型的常量对象，格式如下：

```java
CONSTANT_String_info {
    u1 tag;
    u2 string_index;
}
```
其中，string_index项的值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示一组Unicode字符序列，这组Unicode字符序列最终会被初始化为一个String对象。

CONSTANT_Utf8_info结构用于表示字符串常量的值：

```java
CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
}
```

其中，length指明了bytes[]数组的长度，其类型为u2。

通过翻阅《Java虚拟机规范》，u2表示2字节的无符号数，1字节有8位，2字节有16位。16位无符号数可表示的最大值为2¹⁶ - 1 = 65535。

也就是说，Class文件中常量池的格式规定了其字符串常量的长度不能超过65535。

使用以下方式定义字符串：

```java
String s = "11111...1111";// 其中有65535个字符“1”
```

使用javac编译，同样会得到“错误：常量字符串过长” ，原因在javac的代码中可以找到，在Gen类中有如下代码：

```java
private void checkStringConstant(DiagnosticPosition var1, Object var2) {
    if (this.nerrs == 0 && var2 != null && var2 instanceof String && ((String)var2).length() >= 65535) {
        this.log.error(var1, "limit.string", new Object[0]);
        ++this.nerrs;
    }
}
```
从代码中可以看出，当参数类型为String，并且长度大于或等于65535时，就会导致编译失败。

如果尝试用65534个字符来定义字符串，则代码可以正常编译。



#### 8.13.2 运行期限制

上面提到的String长度的限制是编译器的限制，即使用String s = "";这种字面量方式定义时才会有的限制。


String在运行期也有限制，就是前面提到的Integer.MAX_VALUE，这个值约等于4GB。在运行期，如果String的长度超过这个范围，就可能抛出异常（在JDK1.9之前）。

int是一个32位的变量类型，如果取正数部分，int类型变量最长可以有近4GB的容量，计算过程如下：

```
2^31-1=2147483647个16-bit Unicodecharacter
2147483647×16=34359738352位
34359738352/8=4294967294（byte）
4294967294/1024=4194303.998046875（KB）
4194303.998046875/1024=4095.999980926513671875（MB）
4095.999980926513671875/1024=3.9999999813735485076994296875（GB）

```

很多人会疑惑，编译时最大长度要求小于65535，运行期怎么会出现大于65535的情况呢？例如以下代码：

```java
String s = "";
for (int i = 0; i < 100000 ; i++) {
    s+="i";
}
```

得到的字符串长度就有10万。在实际应用中，如系统对接传输高清图片（对方将图片转成BASE64编码，接收后再转成图片 ），在将BASE64编码后的内容赋值给字符串时就可能抛出异常。



### 小结

字符串有长度限制，在编译期，要求字符串常量池中常量的长度不能超过65535，并且在javac执行过程中控制字符串长度的最大值为65534。

在运行期，字符串的长度不能超过int的范围，否则会抛出异常。 

