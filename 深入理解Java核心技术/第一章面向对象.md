
### 第1章 什么是面向对象

#### 1.1 面向过程与面向对象

相信很多程序员在最初接触Java的时候就听说过，Java是一种面向对象的开发语言，那么什么是面向对象呢？

所谓面向对象，其实是指软件工程中的一类编程风格，很多人称之为开发范式、编程泛型（Programming Paradigm ）。面向对象是众多开发范式中的一种。除了面向对象，还有面向过程、指令式编程和函数式编程等。

虽然近几年函数式编程越来越被人们熟知，但在所有的开发范式中，我们接触最多的还是面向过程和面向对象两种。

本书先介绍什么是面向过程和面向对象，这样能有助于读者更好地学习Java。

1. **什么是面向过程**

面向过程（Procedure Oriented）是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。

简单地说，在面向过程的开发范式中，程序员需要把问题分解成一个个步骤，每个步骤用函数实现，依次调用即可。

也就是说，在进行面向过程编程时，可以先定义一个函数，然后使用诸如if - else、for - each等方式执行代码。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。

基于面向过程进行的软件开发，其代码都是流程化的，可以明确地看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。

但是，面向过程同时存在代码重用性低、扩展能力差、后期维护难度比较大等问题。

2. **什么是面向对象**

面向对象（Object Oriented）的雏形最早出现在1960年的Simula语言中。当时的程序设计领域正面临一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？

面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前，较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby和PHP等。

简单地说，在面向对象的开发范式中，程序员将问题分解成一个个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。

也就是说，在使用面向对象进行编程时，要把属性、行为等封装成对象，然后基于这些对象及对象的能力实现业务逻辑。比如，想要造一辆车，首先要定义车的各种属性，然后将各种属性封装在一起，抽象成一个Car类。

面向对象的编程方法之所以受欢迎，是因为它更加符合人类的思维方式。用这种方式编写出来的代码的扩展性、可维护性都很高。

其实，面向对象也是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。

这里提到的封装、继承、多态便是面向对象的三大基本特征，除此之外，面向对象还有五大基本原则，接下来逐一介绍。



#### 1.2 面向对象的三大基本特征

面向对象的开发范式其实是对现实世界的理解和抽象的方法，那么，具体如何将现实世界抽象成代码呢？这就需要运用面向对象的三大基本特征，分别是封装、继承和多态。

1. **封装（Encapsulation）**

所谓封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类或者对象隐藏信息。

简单地说，一个类就是一个封装了数据及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外地改变或错误地使用了对象的私有部分。

**封装举例**

比如我们想定义一个矩形，先定义一个Rectangle类，然后通过封装的手段放入一些必备数据：

```java
/**
 * 矩形
 */
class Rectangle {
    /**
     * 设置矩形的长度和宽度
     */
    public Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
    }

    /**
     * 长度
     */
    private int length;

    /**
     * 宽度
     */
    private int width;

    /**
     * 获得矩形面积
     *
     * @return
     */
    public int area() {
        return this.length * this.width;
    }
}
```

我们通过封装的方式，给“矩形”定义了“长度”和“宽度”，这就完成了对现实世界中“矩形”的抽象的第一步。

2. **继承（Inheritance）**

继承是指这样一种能力：它可以使用现有类的所有功能，并在无须重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”“父类”“超类”。继承的过程就是从一般到特殊的过程。

**继承举例**

比如我们想定义一个正方形，因为已经有了矩形，所以可以直接继承Rectangle类（正方形是长方形的一种特例）：

```java
/**
 * 正方形，继承自矩形
 */
class Square extends Rectangle {
    /**
     * 设置正方形边长
     *
     * @param length
     */
    public Square(int length) {
        super(length, length);
    }
}
```

在现实世界中，“正方形”是“矩形”的特例，或者说正方形是通过矩形派生出来的，这种派生关系在面向对象中可以用继承来表达。

3. **多态（Polymorphism）**

所谓多态，就是指一个类实例的相同方法在不同情形下有不同的表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。

这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

最常见的多态就是将子类传入父类参数中，当运行时调用父类方法时，通过传入的子类决定具体的内部结构或行为。

关于多态的例子，将在第2章中深入介绍。

在介绍了面向对象的封装、继承、多态三个基本特征之后，我们基本了解了对现实世界抽象的方法。



“一千个读者眼中有一千个哈姆雷特”，说到对现实世界的抽象，虽然方法相同，但是运用同样的方法，最终得到的结果可能千差万别，那么如何评价抽象的结果的好坏呢？

这就要提到面向对象的五大基本原则了，我们参考这五大基本原则来评价一个抽象的结果。



#### 1.3 面向对象的五大基本原则

面向对象开发范式的最大好处就是易用、易扩展、易维护，但是，什么样的代码是易用、易扩展、易维护的呢？如何衡量它们呢？

罗伯特·C·马丁在21世纪早期提出了SOLID原则，这是五个原则缩写的首字母的组合，指代了面向对象编程和面向对象设计的五个基本原则。

SOLID原则包含单一职责原则（Single - Responsibility Principle）、开放封闭原则（Open - Closed Principle）、里氏替换原则（Liskov - Substitution Principle）、接口隔离原则（Interface - Segregation Principle）和依赖倒置原则（Dependence - Inversion Principle）。当这些原则被一起应用时，它们使得程序员开发一个容易进行软件维护和扩展的系统变得更加可能。

1. **单一职责原则（Single - Responsibility Principle）**

单一职责原则的核心思想是：一个类最好只做一件事，只有一个引起它变化的原因。

单一职责原则可以看作高内聚、低耦合在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。

高内聚、低耦合是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计，主要看类的内聚性是否高、耦合度是否低。目的是使程序模块的可重用性、移植性大大增强。

内聚是从功能角度来度量模块内的联系的，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度。

职责过多，可能引起其变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指类只有单一功能，不要为类实现过多的功能点，以保证实体只有一个引起职责变化的原因。

交杂不清的职责会使得代码看起来特别别扭，牵一发而动全身，有失美感，甚至可能导致不可预期的系统错误风险。

2. **开放封闭原则（Open - Closed Principle）**

开放封闭原则的核心思想是：软件实体应该是可扩展且不可修改的。也就是说，对扩展开放、对修改封闭。

开放封闭原则主要体现在两个方面：

（1）对扩展开放，意味着当有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

（2）对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

实现开放封闭原则的核心思想就是对抽象（如接口、抽象类等）编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。

“需求总是变化的”，没有不变的软件，所以就需要用开放封闭原则来封闭变化以满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。

3. **里氏替换原则（Liskov - Substitution Principle）**

里氏替换原则的核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有当子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。

里氏替换原则主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里氏替换原则，才能保证继承复用是可靠的。

里氏替换原则的实现方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过继承的方式，在子类中复写父类的方法，实现新的方式支持同样的职责。

里氏替换原则是关于继承机制的设计原则，若违反了里氏替换原则，则必然导致违反开放封闭原则。

里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。


4. **接口隔离原则（Interface - Segregation Principle）**

接口隔离原则的核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。


接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而“胖”接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而在某些时候，实现类型并非需要所有的接口定义，在设计上这是一种“浪费”，而且在实施上会带来潜在的问题，对“胖”接口的修改将导致需要修改一连串的客户端程序，有时这是一种灾难。在这种情况下，将“胖”接口分解为多个具体的定制化方法，使得客户端仅仅依赖于它们实际调用的方法，从而避免客户端要依赖那些它们根本用不到的方法。

分离接口的手段主要有以下两种：

（1）委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。

（2）多重继承分离，通过接口多继承来实现客户的需求，这种是较好的方式。

5. **依赖倒置原则（Dependence - Inversion Principle）**

依赖倒置原则的核心思想是：程序要依赖于抽象接口，而不是具体的实现。简单地说，就是要对抽象进行编程，不要对实现进行编程。


在面向过程的开发中，上层依赖于下层，当下层发生重大变化时，上层也要跟着变动，这就会导致模块的复用性降低，大大提高了开发的成本。

面向对象的开发很好地解决了这个问题，通过分离接口与实现，使得类与类、模块与模块之间只依赖于接口，而不依赖于具体的实现类。在一般情况下，抽象的接口的变化概率是很小的，依赖接口而不依赖具体实现，即使实现细节不断变动，只要抽象不变，上层依赖就不需要改动。这大大降低了客户程序与实现细节的耦合度。 

以上就是5种基本的面向对象的设计原则，它们就像面向对象程序设计中的“金科玉律”，遵守它们可以使代码更加鲜活、易于复用、易于拓展、灵活优雅。

不同的设计模式对应不同的需求，而设计原则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如Arthur J.Riel在《OOD启示录》中所说的：“你不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看作警铃，若违背了其中的一条，那么警铃就会响起。”

很多人刚开始可能无法深刻地理解这些原则，随着开发经验的增长，就会慢慢地体会。 



